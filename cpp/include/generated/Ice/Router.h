// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'Router.ice'.</auto-generated>
// clang-format off

#ifndef Ice_Router_h_
#define Ice_Router_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include "BuiltinSequences.h"

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

// NOLINTBEGIN(modernize-concat-nested-namespaces)

namespace Ice
{
    class RouterPrx;

    class RouterFinderPrx;
}

namespace Ice
{
    /// Represents an intermediary object that routes requests and replies between clients and Ice objects that are not
    /// directly reachable from these clients.
    /// @headerfile Ice/Ice.h
    class ICE_API RouterPrx : public Ice::Proxy<RouterPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        RouterPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        RouterPrx(const RouterPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        RouterPrx(RouterPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~RouterPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        RouterPrx& operator=(const RouterPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        RouterPrx& operator=(RouterPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Gets the router's client proxy, i.e., the proxy to use for forwarding requests from the client to the
        /// router. If a null proxy is returned, the client will forward requests to the router's endpoints.
        /// @param[out] hasRoutingTable Indicates whether or not the router supports a routing table. If `true`, the Ice
        /// runtime will call ::Ice::RouterPrx::addProxies to populate the routing table. The Ice runtime assumes the router has
        /// a routing table when @p hasRoutingTable is not set. Introduced in Ice 3.7.
        /// @param context The request context.
        /// @return The router's client proxy.
        std::optional<Ice::ObjectPrx> getClientProxy(std::optional<bool>& hasRoutingTable, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets the router's client proxy, i.e., the proxy to use for forwarding requests from the client to the
        /// router. If a null proxy is returned, the client will forward requests to the router's endpoints.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - `returnValue` The router's client proxy.
        /// - `hasRoutingTable` Indicates whether or not the router supports a routing table. If `true`, the Ice
        /// runtime will call ::Ice::RouterPrx::addProxies to populate the routing table. The Ice runtime assumes the router has
        /// a routing table when @p hasRoutingTable is not set. Introduced in Ice 3.7.
        [[nodiscard]] std::future<std::tuple<std::optional<Ice::ObjectPrx>, std::optional<bool>>> getClientProxyAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets the router's client proxy, i.e., the proxy to use for forwarding requests from the client to the
        /// router. If a null proxy is returned, the client will forward requests to the router's endpoints.
        /// @param response The response callback. It accepts:
        /// - `returnValue` The router's client proxy.
        /// - `hasRoutingTable` Indicates whether or not the router supports a routing table. If `true`, the Ice
        /// runtime will call ::Ice::RouterPrx::addProxies to populate the routing table. The Ice runtime assumes the router has
        /// a routing table when @p hasRoutingTable is not set. Introduced in Ice 3.7.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getClientProxyAsync(std::function<void(std::optional<Ice::ObjectPrx>, std::optional<bool>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getClientProxy(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<std::optional<Ice::ObjectPrx>, std::optional<bool>>>>&, const Ice::Context&) const;

        /// Gets the router's server proxy, i.e., the proxy to use for forwarding requests from the server to the
        /// router. The Ice runtime uses the endpoints of this proxy as the published endpoints of bi-dir object
        /// adapters.
        /// @param context The request context.
        /// @return The router's server proxy.
        std::optional<Ice::ObjectPrx> getServerProxy(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets the router's server proxy, i.e., the proxy to use for forwarding requests from the server to the
        /// router. The Ice runtime uses the endpoints of this proxy as the published endpoints of bi-dir object
        /// adapters.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The router's server proxy.
        [[nodiscard]] std::future<std::optional<Ice::ObjectPrx>> getServerProxyAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets the router's server proxy, i.e., the proxy to use for forwarding requests from the server to the
        /// router. The Ice runtime uses the endpoints of this proxy as the published endpoints of bi-dir object
        /// adapters.
        /// @param response The response callback. It accepts:
        /// - The router's server proxy.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getServerProxyAsync(std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getServerProxy(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>&, const Ice::Context&) const;

        /// Adds new proxy information to the router's routing table.
        /// @param proxies The proxies to add. Adding a null proxy is an error.
        /// @param context The request context.
        /// @return Proxies discarded by the router. These proxies are all non-null.
        ObjectProxySeq addProxies(const ObjectProxySeq& proxies, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Adds new proxy information to the router's routing table.
        /// @param proxies The proxies to add. Adding a null proxy is an error.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - Proxies discarded by the router. These proxies are all non-null.
        [[nodiscard]] std::future<ObjectProxySeq> addProxiesAsync(const ObjectProxySeq& proxies, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Adds new proxy information to the router's routing table.
        /// @param proxies The proxies to add. Adding a null proxy is an error.
        /// @param response The response callback. It accepts:
        /// - Proxies discarded by the router. These proxies are all non-null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> addProxiesAsync(const ObjectProxySeq& proxies, std::function<void(::Ice::ObjectProxySeq)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_addProxies(const std::shared_ptr<IceInternal::OutgoingAsyncT<ObjectProxySeq>>&, const ObjectProxySeq&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::Ice::Router"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static RouterPrx _fromReference(IceInternal::ReferencePtr ref) { return RouterPrx{std::move(ref)}; }

    protected:
        /// @private
        RouterPrx() = default;

        /// @private
        explicit RouterPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// Provides access to a RouterPrx object via a fixed identity.
    /// A RouterFinder is always registered with identity `Ice/RouterFinder`. This allows clients to obtain the
    /// associated Router proxy with just the endpoint information of the object. For example, you can use the
    /// RouterFinder proxy `Ice/RouterFinder:tcp -h somehost -p 4061` to get the Router proxy
    /// `MyGlacier2/Router:tcp -h somehost -p 4061`.
    /// @headerfile Ice/Ice.h
    class ICE_API RouterFinderPrx : public Ice::Proxy<RouterFinderPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        RouterFinderPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        RouterFinderPrx(const RouterFinderPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        RouterFinderPrx(RouterFinderPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~RouterFinderPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        RouterFinderPrx& operator=(const RouterFinderPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        RouterFinderPrx& operator=(RouterFinderPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Gets a proxy to the associated ::Ice::RouterPrx. The proxy might point to several replicas.
        /// @param context The request context.
        /// @return The router proxy. This proxy is never null.
        std::optional<RouterPrx> getRouter(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets a proxy to the associated ::Ice::RouterPrx. The proxy might point to several replicas.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The router proxy. This proxy is never null.
        [[nodiscard]] std::future<std::optional<RouterPrx>> getRouterAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets a proxy to the associated ::Ice::RouterPrx. The proxy might point to several replicas.
        /// @param response The response callback. It accepts:
        /// - The router proxy. This proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getRouterAsync(std::function<void(std::optional<::Ice::RouterPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getRouter(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<RouterPrx>>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::Ice::RouterFinder"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static RouterFinderPrx _fromReference(IceInternal::ReferencePtr ref) { return RouterFinderPrx{std::move(ref)}; }

    protected:
        /// @private
        RouterFinderPrx() = default;

        /// @private
        explicit RouterFinderPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };
}

namespace Ice
{
    /// Represents an intermediary object that routes requests and replies between clients and Ice objects that are not
    /// directly reachable from these clients.
    /// @headerfile Ice/Ice.h
    class ICE_API Router : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = RouterPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(IncomingRequest& request, std::function<void(OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Gets the router's client proxy, i.e., the proxy to use for forwarding requests from the client to the
        /// router. If a null proxy is returned, the client will forward requests to the router's endpoints.
        /// @param[out] hasRoutingTable Indicates whether or not the router supports a routing table. If `true`, the Ice
        /// runtime will call ::Ice::RouterPrx::addProxies to populate the routing table. The Ice runtime assumes the router has
        /// a routing table when @p hasRoutingTable is not set. Introduced in Ice 3.7.
        /// @param current The Current object of the incoming request.
        /// @return The router's client proxy.
        virtual std::optional<Ice::ObjectPrx> getClientProxy(std::optional<bool>& hasRoutingTable, const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getClientProxy(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Gets the router's server proxy, i.e., the proxy to use for forwarding requests from the server to the
        /// router. The Ice runtime uses the endpoints of this proxy as the published endpoints of bi-dir object
        /// adapters.
        /// @param current The Current object of the incoming request.
        /// @return The router's server proxy.
        [[nodiscard]] virtual std::optional<Ice::ObjectPrx> getServerProxy(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getServerProxy(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Adds new proxy information to the router's routing table.
        /// @param proxies The proxies to add. Adding a null proxy is an error.
        /// @param current The Current object of the incoming request.
        /// @return Proxies discarded by the router. These proxies are all non-null.
        virtual ObjectProxySeq addProxies(ObjectProxySeq proxies, const Ice::Current& current) = 0;

        /// @private
        void _iceD_addProxies(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::Ice::Router"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Router.
    using RouterPtr = std::shared_ptr<Router>;

    /// Provides access to a RouterPrx object via a fixed identity.
    /// A RouterFinder is always registered with identity `Ice/RouterFinder`. This allows clients to obtain the
    /// associated Router proxy with just the endpoint information of the object. For example, you can use the
    /// RouterFinder proxy `Ice/RouterFinder:tcp -h somehost -p 4061` to get the Router proxy
    /// `MyGlacier2/Router:tcp -h somehost -p 4061`.
    /// @headerfile Ice/Ice.h
    class ICE_API RouterFinder : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = RouterFinderPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(IncomingRequest& request, std::function<void(OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Gets a proxy to the associated ::Ice::RouterPrx. The proxy might point to several replicas.
        /// @param current The Current object of the incoming request.
        /// @return The router proxy. This proxy is never null.
        virtual std::optional<RouterPrx> getRouter(const Ice::Current& current) = 0;

        /// @private
        void _iceD_getRouter(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::Ice::RouterFinder"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a RouterFinder.
    using RouterFinderPtr = std::shared_ptr<RouterFinder>;
}

// NOLINTEND(modernize-concat-nested-namespaces)

#include <Ice/PopDisableWarnings.h>
#endif
