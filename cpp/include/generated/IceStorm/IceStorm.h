// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'IceStorm.ice'.</auto-generated>
// clang-format off

#ifndef IceStorm_IceStorm_h_
#define IceStorm_IceStorm_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include "Metrics.h"
#include <IceStorm/Config.h>

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifndef ICESTORM_API
#   if defined(ICESTORM_API_EXPORTS)
#       define ICESTORM_API ICE_DECLSPEC_EXPORT
#   else
#       define ICESTORM_API ICE_DECLSPEC_IMPORT
#   endif
#endif

// NOLINTBEGIN(modernize-concat-nested-namespaces)

/// Lightweight publish/subscribe framework, available for all Ice language mappings.
namespace IceStorm
{
    class TopicPrx;

    struct LinkInfo;

    /// A sequence of LinkInfo objects.
    using LinkInfoSeq = std::vector<LinkInfo>;

    /// Quality of service parameters.
    /// @see Topic#subscribeAndGetPublisher
    using QoS = std::map<std::string, std::string>;

    /// A dictionary of topic name to topic proxy.
    using TopicDict = std::map<std::string, std::optional<TopicPrx>>;

    class TopicManagerPrx;

    class FinderPrx;
}

namespace IceStorm
{
    /// Represents an IceStorm topic. Publishers publish data to a topic (via the topic's publisher object), and
    /// subscribers subscribe to a topic.
    /// @see TopicManager
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API TopicPrx : public Ice::Proxy<TopicPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        TopicPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        TopicPrx(const TopicPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        TopicPrx(TopicPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~TopicPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        TopicPrx& operator=(const TopicPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        TopicPrx& operator=(TopicPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Gets the name of this topic.
        /// @param context The request context.
        /// @return The name of the topic.
        /// @see TopicManager#create
        std::string getName(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets the name of this topic.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The name of the topic.
        /// @see TopicManager#create
        [[nodiscard]] std::future<std::string> getNameAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets the name of this topic.
        /// @param response The response callback. It accepts:
        /// - The name of the topic.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        /// @see TopicManager#create
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getNameAsync(std::function<void(std::string)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getName(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::string>>&, const Ice::Context&) const;

        /// Gets a proxy to a publisher object for this topic. To publish data to a topic, a publisher calls this
        /// operation and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
        /// deployment is used, this call may return a replicated proxy.
        /// @param context The request context.
        /// @return A proxy to publish data on this topic. This proxy is never null.
        std::optional<Ice::ObjectPrx> getPublisher(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets a proxy to a publisher object for this topic. To publish data to a topic, a publisher calls this
        /// operation and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
        /// deployment is used, this call may return a replicated proxy.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A proxy to publish data on this topic. This proxy is never null.
        [[nodiscard]] std::future<std::optional<Ice::ObjectPrx>> getPublisherAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets a proxy to a publisher object for this topic. To publish data to a topic, a publisher calls this
        /// operation and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
        /// deployment is used, this call may return a replicated proxy.
        /// @param response The response callback. It accepts:
        /// - A proxy to publish data on this topic. This proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getPublisherAsync(std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getPublisher(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>&, const Ice::Context&) const;

        /// Gets a non-replicated proxy to a publisher object for this topic. To publish data to a topic, a publisher
        /// calls this operation and then creates a proxy with the publisher type from this proxy.
        /// @param context The request context.
        /// @return A proxy to publish data on this topic. This proxy is never null.
        std::optional<Ice::ObjectPrx> getNonReplicatedPublisher(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets a non-replicated proxy to a publisher object for this topic. To publish data to a topic, a publisher
        /// calls this operation and then creates a proxy with the publisher type from this proxy.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A proxy to publish data on this topic. This proxy is never null.
        [[nodiscard]] std::future<std::optional<Ice::ObjectPrx>> getNonReplicatedPublisherAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets a non-replicated proxy to a publisher object for this topic. To publish data to a topic, a publisher
        /// calls this operation and then creates a proxy with the publisher type from this proxy.
        /// @param response The response callback. It accepts:
        /// - A proxy to publish data on this topic. This proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getNonReplicatedPublisherAsync(std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getNonReplicatedPublisher(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>&, const Ice::Context&) const;

        /// Subscribes to this topic.
        /// @param theQoS The quality of service parameters for this subscription.
        /// @param subscriber The subscriber's proxy. This proxy is never null.
        /// @param context The request context.
        /// @return The per-subscriber publisher proxy. This proxy is never null.
        /// @throws IceStorm::AlreadySubscribed Thrown when @p subscriber is already subscribed.
        /// @throws IceStorm::BadQoS Thrown when @p theQoS is unavailable or invalid.
        /// @see #unsubscribe
        std::optional<Ice::ObjectPrx> subscribeAndGetPublisher(const QoS& theQoS, const std::optional<Ice::ObjectPrx>& subscriber, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Subscribes to this topic.
        /// @param theQoS The quality of service parameters for this subscription.
        /// @param subscriber The subscriber's proxy. This proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The per-subscriber publisher proxy. This proxy is never null.
        /// @see #unsubscribe
        [[nodiscard]] std::future<std::optional<Ice::ObjectPrx>> subscribeAndGetPublisherAsync(const QoS& theQoS, const std::optional<Ice::ObjectPrx>& subscriber, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Subscribes to this topic.
        /// @param theQoS The quality of service parameters for this subscription.
        /// @param subscriber The subscriber's proxy. This proxy is never null.
        /// @param response The response callback. It accepts:
        /// - The per-subscriber publisher proxy. This proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        /// @see #unsubscribe
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> subscribeAndGetPublisherAsync(const QoS& theQoS, const std::optional<Ice::ObjectPrx>& subscriber, std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_subscribeAndGetPublisher(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>&, const QoS&, const std::optional<Ice::ObjectPrx>&, const Ice::Context&) const;

        /// Unsubscribes the provided @p subscriber from this topic.
        /// @param subscriber A proxy to an existing subscriber. This proxy is never null.
        /// @param context The request context.
        /// @see #subscribeAndGetPublisher
        void unsubscribe(const std::optional<Ice::ObjectPrx>& subscriber, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Unsubscribes the provided @p subscriber from this topic.
        /// @param subscriber A proxy to an existing subscriber. This proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        /// @see #subscribeAndGetPublisher
        [[nodiscard]] std::future<void> unsubscribeAsync(const std::optional<Ice::ObjectPrx>& subscriber, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Unsubscribes the provided @p subscriber from this topic.
        /// @param subscriber A proxy to an existing subscriber. This proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        /// @see #subscribeAndGetPublisher
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> unsubscribeAsync(const std::optional<Ice::ObjectPrx>& subscriber, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_unsubscribe(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const std::optional<Ice::ObjectPrx>&, const Ice::Context&) const;

        /// Creates a link to another topic. All events originating on this topic will also be sent to the other topic.
        /// @param linkTo The topic to link to. This proxy is never null.
        /// @param cost The cost of the link.
        /// @param context The request context.
        /// @throws IceStorm::LinkExists Thrown when a link to @p linkTo already exists.
        void link(const std::optional<TopicPrx>& linkTo, std::int32_t cost, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Creates a link to another topic. All events originating on this topic will also be sent to the other topic.
        /// @param linkTo The topic to link to. This proxy is never null.
        /// @param cost The cost of the link.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> linkAsync(const std::optional<TopicPrx>& linkTo, std::int32_t cost, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Creates a link to another topic. All events originating on this topic will also be sent to the other topic.
        /// @param linkTo The topic to link to. This proxy is never null.
        /// @param cost The cost of the link.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> linkAsync(const std::optional<TopicPrx>& linkTo, std::int32_t cost, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_link(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const std::optional<TopicPrx>&, std::int32_t, const Ice::Context&) const;

        /// Destroys a link from this topic to the provided topic.
        /// @param linkTo The topic to destroy the link to. This proxy is never null.
        /// @param context The request context.
        /// @throws IceStorm::NoSuchLink Thrown when a link to @p linkTo does not exist.
        void unlink(const std::optional<TopicPrx>& linkTo, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Destroys a link from this topic to the provided topic.
        /// @param linkTo The topic to destroy the link to. This proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> unlinkAsync(const std::optional<TopicPrx>& linkTo, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Destroys a link from this topic to the provided topic.
        /// @param linkTo The topic to destroy the link to. This proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> unlinkAsync(const std::optional<TopicPrx>& linkTo, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_unlink(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const std::optional<TopicPrx>&, const Ice::Context&) const;

        /// Gets information on the current links.
        /// @param context The request context.
        /// @return A sequence of LinkInfo objects.
        LinkInfoSeq getLinkInfoSeq(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets information on the current links.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A sequence of LinkInfo objects.
        [[nodiscard]] std::future<LinkInfoSeq> getLinkInfoSeqAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets information on the current links.
        /// @param response The response callback. It accepts:
        /// - A sequence of LinkInfo objects.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getLinkInfoSeqAsync(std::function<void(::IceStorm::LinkInfoSeq)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getLinkInfoSeq(const std::shared_ptr<IceInternal::OutgoingAsyncT<LinkInfoSeq>>&, const Ice::Context&) const;

        /// Gets the list of subscribers for this topic.
        /// @param context The request context.
        /// @return The sequence of Ice identities for the subscriber objects.
        ::Ice::IdentitySeq getSubscribers(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets the list of subscribers for this topic.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The sequence of Ice identities for the subscriber objects.
        [[nodiscard]] std::future<::Ice::IdentitySeq> getSubscribersAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets the list of subscribers for this topic.
        /// @param response The response callback. It accepts:
        /// - The sequence of Ice identities for the subscriber objects.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getSubscribersAsync(std::function<void(::Ice::IdentitySeq)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getSubscribers(const std::shared_ptr<IceInternal::OutgoingAsyncT<::Ice::IdentitySeq>>&, const Ice::Context&) const;

        /// Destroys this topic.
        /// @param context The request context.
        void destroy(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Destroys this topic.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> destroyAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Destroys this topic.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> destroyAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_destroy(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::Topic"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static TopicPrx _fromReference(IceInternal::ReferencePtr ref) { return TopicPrx{std::move(ref)}; }

    protected:
        /// @private
        TopicPrx() = default;

        /// @private
        explicit TopicPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// Represents an object that manages topics.
    /// @see Topic
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API TopicManagerPrx : public Ice::Proxy<TopicManagerPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        TopicManagerPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        TopicManagerPrx(const TopicManagerPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        TopicManagerPrx(TopicManagerPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~TopicManagerPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        TopicManagerPrx& operator=(const TopicManagerPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        TopicManagerPrx& operator=(TopicManagerPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Creates a new topic.
        /// @param name The name of the topic.
        /// @param context The request context.
        /// @return A proxy to the new topic object. The returned proxy is never null.
        /// @throws IceStorm::TopicExists Thrown when a topic with the same name already exists.
        std::optional<TopicPrx> create(std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Creates a new topic.
        /// @param name The name of the topic.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A proxy to the new topic object. The returned proxy is never null.
        [[nodiscard]] std::future<std::optional<TopicPrx>> createAsync(std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Creates a new topic.
        /// @param name The name of the topic.
        /// @param response The response callback. It accepts:
        /// - A proxy to the new topic object. The returned proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> createAsync(std::string_view name, std::function<void(std::optional<::IceStorm::TopicPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_create(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<TopicPrx>>>&, std::string_view, const Ice::Context&) const;

        /// Retrieves a topic by name.
        /// @param name The name of the topic.
        /// @param context The request context.
        /// @return A proxy to the topic object. The returned proxy is never null.
        /// @throws IceStorm::NoSuchTopic Thrown when there is no topic named @p name.
        std::optional<TopicPrx> retrieve(std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Retrieves a topic by name.
        /// @param name The name of the topic.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A proxy to the topic object. The returned proxy is never null.
        [[nodiscard]] std::future<std::optional<TopicPrx>> retrieveAsync(std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Retrieves a topic by name.
        /// @param name The name of the topic.
        /// @param response The response callback. It accepts:
        /// - A proxy to the topic object. The returned proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> retrieveAsync(std::string_view name, std::function<void(std::optional<::IceStorm::TopicPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_retrieve(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<TopicPrx>>>&, std::string_view, const Ice::Context&) const;

        /// Retrieves all topics managed by this topic manager.
        /// @param context The request context.
        /// @return A dictionary of string, topic proxy pairs.
        TopicDict retrieveAll(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Retrieves all topics managed by this topic manager.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A dictionary of string, topic proxy pairs.
        [[nodiscard]] std::future<TopicDict> retrieveAllAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Retrieves all topics managed by this topic manager.
        /// @param response The response callback. It accepts:
        /// - A dictionary of string, topic proxy pairs.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> retrieveAllAsync(std::function<void(::IceStorm::TopicDict)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_retrieveAll(const std::shared_ptr<IceInternal::OutgoingAsyncT<TopicDict>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicManager"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static TopicManagerPrx _fromReference(IceInternal::ReferencePtr ref) { return TopicManagerPrx{std::move(ref)}; }

    protected:
        /// @private
        TopicManagerPrx() = default;

        /// @private
        explicit TopicManagerPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// Provides access to a TopicManagerPrx object via a fixed identity.
    /// An IceStorm Finder is always registered with identity `IceStorm/Finder`. This allows clients to obtain the
    /// associated TopicManager proxy with just the endpoint information of the object. For example, you can use the
    /// Finder proxy `IceStorm/Finder:tcp -h somehost -p 4061` to get the TopicManager proxy
    /// `MyIceStorm/TopicManager:tcp -h somehost -p 4061`.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API FinderPrx : public Ice::Proxy<FinderPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        FinderPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        FinderPrx(const FinderPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        FinderPrx(FinderPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~FinderPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        FinderPrx& operator=(const FinderPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        FinderPrx& operator=(FinderPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Gets a proxy to the associated ::IceStorm::TopicManagerPrx. The proxy might point to several replicas.
        /// @param context The request context.
        /// @return The topic manager proxy. This proxy is never null.
        std::optional<TopicManagerPrx> getTopicManager(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Gets a proxy to the associated ::IceStorm::TopicManagerPrx. The proxy might point to several replicas.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The topic manager proxy. This proxy is never null.
        [[nodiscard]] std::future<std::optional<TopicManagerPrx>> getTopicManagerAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Gets a proxy to the associated ::IceStorm::TopicManagerPrx. The proxy might point to several replicas.
        /// @param response The response callback. It accepts:
        /// - The topic manager proxy. This proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getTopicManagerAsync(std::function<void(std::optional<::IceStorm::TopicManagerPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getTopicManager(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<TopicManagerPrx>>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::Finder"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static FinderPrx _fromReference(IceInternal::ReferencePtr ref) { return FinderPrx{std::move(ref)}; }

    protected:
        /// @private
        FinderPrx() = default;

        /// @private
        explicit FinderPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };
}

namespace IceStorm
{
    /// Information about a topic link.
    /// @headerfile IceStorm/IceStorm.h
    struct LinkInfo
    {
        /// The linked topic proxy. This proxy is never null.
        std::optional<::IceStorm::TopicPrx> theTopic;

        /// The name of the linked topic.
        std::string name;

        /// The cost of traversing this link.
        std::int32_t cost;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::optional<::IceStorm::TopicPrx>&, const std::string&, const std::int32_t&> ice_tuple() const
        {
            return std::tie(theTopic, name, cost);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        ICESTORM_API void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a LinkInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    ICESTORM_API std::ostream& operator<<(std::ostream& os, const LinkInfo& value);

    /// The exception that is thrown when attempting to create a link that already exists.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API LinkExists : public Ice::UserException
    {
    public:
        /// Default constructor.
        LinkExists() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param name The name of the linked topic.
        LinkExists(std::string name) noexcept :
            name(std::move(name))
        {
        }

        /// Copy constructor.
        LinkExists(const LinkExists&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const std::string&> ice_tuple() const
        {
            return std::tie(name);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::LinkExists"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        /// The name of the linked topic.
        std::string name;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// The exception that is thrown when attempting to remove a link that does not exist.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API NoSuchLink : public Ice::UserException
    {
    public:
        /// Default constructor.
        NoSuchLink() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param name The name of the link that does not exist.
        NoSuchLink(std::string name) noexcept :
            name(std::move(name))
        {
        }

        /// Copy constructor.
        NoSuchLink(const NoSuchLink&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const std::string&> ice_tuple() const
        {
            return std::tie(name);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::NoSuchLink"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        /// The name of the link that does not exist.
        std::string name;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// The exception that is thrown when attempting to subscribe a proxy for which a subscription already exists.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API AlreadySubscribed : public Ice::UserException
    {
    public:
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::AlreadySubscribed"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// The exception that is thrown when attempting to subscribe with an invalid QoS.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API BadQoS : public Ice::UserException
    {
    public:
        /// Default constructor.
        BadQoS() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param reason The reason for the failure.
        BadQoS(std::string reason) noexcept :
            reason(std::move(reason))
        {
        }

        /// Copy constructor.
        BadQoS(const BadQoS&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const std::string&> ice_tuple() const
        {
            return std::tie(reason);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::BadQoS"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        /// The reason for the failure.
        std::string reason;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// The exception that is thrown when attempting to create a topic that already exists.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API TopicExists : public Ice::UserException
    {
    public:
        /// Default constructor.
        TopicExists() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param name The name of the topic that already exists.
        TopicExists(std::string name) noexcept :
            name(std::move(name))
        {
        }

        /// Copy constructor.
        TopicExists(const TopicExists&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const std::string&> ice_tuple() const
        {
            return std::tie(name);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::TopicExists"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        /// The name of the topic that already exists.
        std::string name;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// The exception that is thrown when attempting to retrieve a topic that does not exist.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API NoSuchTopic : public Ice::UserException
    {
    public:
        /// Default constructor.
        NoSuchTopic() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param name The name of the topic that does not exist.
        NoSuchTopic(std::string name) noexcept :
            name(std::move(name))
        {
        }

        /// Copy constructor.
        NoSuchTopic(const NoSuchTopic&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const std::string&> ice_tuple() const
        {
            return std::tie(name);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::NoSuchTopic"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        /// The name of the topic that does not exist.
        std::string name;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// @cond INTERNAL
    using Ice::Tuple::operator<;
    using Ice::Tuple::operator<=;
    using Ice::Tuple::operator>;
    using Ice::Tuple::operator>=;
    using Ice::Tuple::operator==;
    using Ice::Tuple::operator!=;
    /// @endcond
}

namespace IceStorm
{
    /// Represents an IceStorm topic. Publishers publish data to a topic (via the topic's publisher object), and
    /// subscribers subscribe to a topic.
    /// @see TopicManager
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API Topic : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = TopicPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Gets the name of this topic.
        /// @param current The Current object of the incoming request.
        /// @return The name of the topic.
        /// @see TopicManager#create
        [[nodiscard]] virtual std::string getName(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getName(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Gets a proxy to a publisher object for this topic. To publish data to a topic, a publisher calls this
        /// operation and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
        /// deployment is used, this call may return a replicated proxy.
        /// @param current The Current object of the incoming request.
        /// @return A proxy to publish data on this topic. This proxy is never null.
        [[nodiscard]] virtual std::optional<Ice::ObjectPrx> getPublisher(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getPublisher(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Gets a non-replicated proxy to a publisher object for this topic. To publish data to a topic, a publisher
        /// calls this operation and then creates a proxy with the publisher type from this proxy.
        /// @param current The Current object of the incoming request.
        /// @return A proxy to publish data on this topic. This proxy is never null.
        [[nodiscard]] virtual std::optional<Ice::ObjectPrx> getNonReplicatedPublisher(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getNonReplicatedPublisher(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Subscribes to this topic.
        /// @param theQoS The quality of service parameters for this subscription.
        /// @param subscriber The subscriber's proxy. This proxy is never null.
        /// @param current The Current object of the incoming request.
        /// @return The per-subscriber publisher proxy. This proxy is never null.
        /// @throws IceStorm::AlreadySubscribed Thrown when @p subscriber is already subscribed.
        /// @throws IceStorm::BadQoS Thrown when @p theQoS is unavailable or invalid.
        /// @see #unsubscribe
        virtual std::optional<Ice::ObjectPrx> subscribeAndGetPublisher(QoS theQoS, std::optional<Ice::ObjectPrx> subscriber, const Ice::Current& current) = 0;

        /// @private
        void _iceD_subscribeAndGetPublisher(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Unsubscribes the provided @p subscriber from this topic.
        /// @param subscriber A proxy to an existing subscriber. This proxy is never null.
        /// @param current The Current object of the incoming request.
        /// @see #subscribeAndGetPublisher
        virtual void unsubscribe(std::optional<Ice::ObjectPrx> subscriber, const Ice::Current& current) = 0;

        /// @private
        void _iceD_unsubscribe(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Creates a link to another topic. All events originating on this topic will also be sent to the other topic.
        /// @param linkTo The topic to link to. This proxy is never null.
        /// @param cost The cost of the link.
        /// @param current The Current object of the incoming request.
        /// @throws IceStorm::LinkExists Thrown when a link to @p linkTo already exists.
        virtual void link(std::optional<TopicPrx> linkTo, std::int32_t cost, const Ice::Current& current) = 0;

        /// @private
        void _iceD_link(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Destroys a link from this topic to the provided topic.
        /// @param linkTo The topic to destroy the link to. This proxy is never null.
        /// @param current The Current object of the incoming request.
        /// @throws IceStorm::NoSuchLink Thrown when a link to @p linkTo does not exist.
        virtual void unlink(std::optional<TopicPrx> linkTo, const Ice::Current& current) = 0;

        /// @private
        void _iceD_unlink(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets information on the current links.
        /// @param current The Current object of the incoming request.
        /// @return A sequence of LinkInfo objects.
        [[nodiscard]] virtual LinkInfoSeq getLinkInfoSeq(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getLinkInfoSeq(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Gets the list of subscribers for this topic.
        /// @param current The Current object of the incoming request.
        /// @return The sequence of Ice identities for the subscriber objects.
        [[nodiscard]] virtual ::Ice::IdentitySeq getSubscribers(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getSubscribers(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Destroys this topic.
        /// @param current The Current object of the incoming request.
        virtual void destroy(const Ice::Current& current) = 0;

        /// @private
        void _iceD_destroy(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::Topic"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Topic.
    using TopicPtr = std::shared_ptr<Topic>;

    /// Represents an object that manages topics.
    /// @see Topic
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API TopicManager : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = TopicManagerPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Creates a new topic.
        /// @param name The name of the topic.
        /// @param current The Current object of the incoming request.
        /// @return A proxy to the new topic object. The returned proxy is never null.
        /// @throws IceStorm::TopicExists Thrown when a topic with the same name already exists.
        virtual std::optional<TopicPrx> create(std::string name, const Ice::Current& current) = 0;

        /// @private
        void _iceD_create(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Retrieves a topic by name.
        /// @param name The name of the topic.
        /// @param current The Current object of the incoming request.
        /// @return A proxy to the topic object. The returned proxy is never null.
        /// @throws IceStorm::NoSuchTopic Thrown when there is no topic named @p name.
        virtual std::optional<TopicPrx> retrieve(std::string name, const Ice::Current& current) = 0;

        /// @private
        void _iceD_retrieve(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Retrieves all topics managed by this topic manager.
        /// @param current The Current object of the incoming request.
        /// @return A dictionary of string, topic proxy pairs.
        virtual TopicDict retrieveAll(const Ice::Current& current) = 0;

        /// @private
        void _iceD_retrieveAll(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicManager"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a TopicManager.
    using TopicManagerPtr = std::shared_ptr<TopicManager>;

    /// Provides access to a TopicManagerPrx object via a fixed identity.
    /// An IceStorm Finder is always registered with identity `IceStorm/Finder`. This allows clients to obtain the
    /// associated TopicManager proxy with just the endpoint information of the object. For example, you can use the
    /// Finder proxy `IceStorm/Finder:tcp -h somehost -p 4061` to get the TopicManager proxy
    /// `MyIceStorm/TopicManager:tcp -h somehost -p 4061`.
    /// @headerfile IceStorm/IceStorm.h
    class ICESTORM_API Finder : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = FinderPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Gets a proxy to the associated ::IceStorm::TopicManagerPrx. The proxy might point to several replicas.
        /// @param current The Current object of the incoming request.
        /// @return The topic manager proxy. This proxy is never null.
        virtual std::optional<TopicManagerPrx> getTopicManager(const Ice::Current& current) = 0;

        /// @private
        void _iceD_getTopicManager(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::Finder"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Finder.
    using FinderPtr = std::shared_ptr<Finder>;
}

namespace Ice
{
    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStorm::LinkInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 7;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::IceStorm::LinkInfo>
    {
        /// Unmarshals a ::IceStorm::LinkInfo from the input stream.
        static void read(InputStream* istr, ::IceStorm::LinkInfo& v)
        {
            istr->readAll(v.theTopic, v.name, v.cost);
        }
    };
    /// @endcond
}

// NOLINTEND(modernize-concat-nested-namespaces)

#include <Ice/PopDisableWarnings.h>
#endif
