// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'Contract.ice'.</auto-generated>

#define ICE_BUILDING_GENERATED_CODE

#include "DataStorm/Contract.h"
#include <Ice/AsyncResponseHandler.h>
#include <Ice/DefaultSliceLoader.h>
#include <Ice/OutgoingAsync.h>
#include <algorithm>
#include <array>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

std::ostream&
DataStormContract::operator<<(std::ostream& os, ClearHistoryPolicy value)
{
    switch (value)
    {
        case ClearHistoryPolicy::OnAdd:
            return os << "OnAdd";
        case ClearHistoryPolicy::OnRemove:
            return os << "OnRemove";
        case ClearHistoryPolicy::OnAll:
            return os << "OnAll";
        case ClearHistoryPolicy::OnAllExceptPartialUpdate:
            return os << "OnAllExceptPartialUpdate";
        case ClearHistoryPolicy::Never:
            return os << "Never";
        default:
            return os << static_cast<std::int32_t>(value);
    }
}

std::ostream&
DataStormContract::operator<<(std::ostream& os, SessionCreationError value)
{
    switch (value)
    {
        case SessionCreationError::AlreadyConnected:
            return os << "AlreadyConnected";
        case SessionCreationError::NodeShutdown:
            return os << "NodeShutdown";
        case SessionCreationError::SessionNotFound:
            return os << "SessionNotFound";
        case SessionCreationError::Internal:
            return os << "Internal";
        default:
            return os << static_cast<std::int32_t>(value);
    }
}

namespace
{
    const IceInternal::ClassInit<::DataStormContract::ElementConfig> iceC_DataStormContract_ElementConfig_init{1};
    const IceInternal::ExceptionInit<::DataStormContract::SessionCreationException> iceC_DataStormContract_SessionCreationException_init;
}

DataStormContract::SessionPrx::~SessionPrx() = default;

void
DataStormContract::SessionPrx::announceTopics(const TopicInfoSeq& iceP_topics, bool iceP_initialize, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_announceTopics, iceP_topics, iceP_initialize, context).get();
}

std::future<void>
DataStormContract::SessionPrx::announceTopicsAsync(const TopicInfoSeq& iceP_topics, bool iceP_initialize, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_announceTopics, iceP_topics, iceP_initialize, context);
}

std::function<void()>
DataStormContract::SessionPrx::announceTopicsAsync(const TopicInfoSeq& iceP_topics, bool iceP_initialize, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_announceTopics, iceP_topics, iceP_initialize, context);
}

void
DataStormContract::SessionPrx::_iceI_announceTopics(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const TopicInfoSeq& iceP_topics, bool iceP_initialize, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "announceTopics";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topics, iceP_initialize);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::attachTopic(const TopicSpec& iceP_topic, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_attachTopic, iceP_topic, context).get();
}

std::future<void>
DataStormContract::SessionPrx::attachTopicAsync(const TopicSpec& iceP_topic, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_attachTopic, iceP_topic, context);
}

std::function<void()>
DataStormContract::SessionPrx::attachTopicAsync(const TopicSpec& iceP_topic, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_attachTopic, iceP_topic, context);
}

void
DataStormContract::SessionPrx::_iceI_attachTopic(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const TopicSpec& iceP_topic, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "attachTopic";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topic);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::detachTopic(std::int64_t iceP_topicId, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_detachTopic, iceP_topicId, context).get();
}

std::future<void>
DataStormContract::SessionPrx::detachTopicAsync(std::int64_t iceP_topicId, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_detachTopic, iceP_topicId, context);
}

std::function<void()>
DataStormContract::SessionPrx::detachTopicAsync(std::int64_t iceP_topicId, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_detachTopic, iceP_topicId, context);
}

void
DataStormContract::SessionPrx::_iceI_detachTopic(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "detachTopic";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::attachTags(std::int64_t iceP_topicId, const ElementInfoSeq& iceP_tags, bool iceP_initialize, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_attachTags, iceP_topicId, iceP_tags, iceP_initialize, context).get();
}

std::future<void>
DataStormContract::SessionPrx::attachTagsAsync(std::int64_t iceP_topicId, const ElementInfoSeq& iceP_tags, bool iceP_initialize, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_attachTags, iceP_topicId, iceP_tags, iceP_initialize, context);
}

std::function<void()>
DataStormContract::SessionPrx::attachTagsAsync(std::int64_t iceP_topicId, const ElementInfoSeq& iceP_tags, bool iceP_initialize, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_attachTags, iceP_topicId, iceP_tags, iceP_initialize, context);
}

void
DataStormContract::SessionPrx::_iceI_attachTags(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const ElementInfoSeq& iceP_tags, bool iceP_initialize, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "attachTags";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_tags, iceP_initialize);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::detachTags(std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_tags, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_detachTags, iceP_topicId, iceP_tags, context).get();
}

std::future<void>
DataStormContract::SessionPrx::detachTagsAsync(std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_tags, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_detachTags, iceP_topicId, iceP_tags, context);
}

std::function<void()>
DataStormContract::SessionPrx::detachTagsAsync(std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_tags, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_detachTags, iceP_topicId, iceP_tags, context);
}

void
DataStormContract::SessionPrx::_iceI_detachTags(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_tags, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "detachTags";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_tags);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::announceElements(std::int64_t iceP_topicId, const ElementInfoSeq& iceP_elements, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_announceElements, iceP_topicId, iceP_elements, context).get();
}

std::future<void>
DataStormContract::SessionPrx::announceElementsAsync(std::int64_t iceP_topicId, const ElementInfoSeq& iceP_elements, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_announceElements, iceP_topicId, iceP_elements, context);
}

std::function<void()>
DataStormContract::SessionPrx::announceElementsAsync(std::int64_t iceP_topicId, const ElementInfoSeq& iceP_elements, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_announceElements, iceP_topicId, iceP_elements, context);
}

void
DataStormContract::SessionPrx::_iceI_announceElements(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const ElementInfoSeq& iceP_elements, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "announceElements";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_elements);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::attachElements(std::int64_t iceP_topicId, const ElementSpecSeq& iceP_elements, bool iceP_initialize, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_attachElements, iceP_topicId, iceP_elements, iceP_initialize, context).get();
}

std::future<void>
DataStormContract::SessionPrx::attachElementsAsync(std::int64_t iceP_topicId, const ElementSpecSeq& iceP_elements, bool iceP_initialize, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_attachElements, iceP_topicId, iceP_elements, iceP_initialize, context);
}

std::function<void()>
DataStormContract::SessionPrx::attachElementsAsync(std::int64_t iceP_topicId, const ElementSpecSeq& iceP_elements, bool iceP_initialize, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_attachElements, iceP_topicId, iceP_elements, iceP_initialize, context);
}

void
DataStormContract::SessionPrx::_iceI_attachElements(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const ElementSpecSeq& iceP_elements, bool iceP_initialize, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "attachElements";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_elements, iceP_initialize);
            ostr->writePendingValues();
        },
        nullptr);
}

void
DataStormContract::SessionPrx::attachElementsAck(std::int64_t iceP_topicId, const ElementSpecAckSeq& iceP_elements, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_attachElementsAck, iceP_topicId, iceP_elements, context).get();
}

std::future<void>
DataStormContract::SessionPrx::attachElementsAckAsync(std::int64_t iceP_topicId, const ElementSpecAckSeq& iceP_elements, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_attachElementsAck, iceP_topicId, iceP_elements, context);
}

std::function<void()>
DataStormContract::SessionPrx::attachElementsAckAsync(std::int64_t iceP_topicId, const ElementSpecAckSeq& iceP_elements, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_attachElementsAck, iceP_topicId, iceP_elements, context);
}

void
DataStormContract::SessionPrx::_iceI_attachElementsAck(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const ElementSpecAckSeq& iceP_elements, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "attachElementsAck";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_elements);
            ostr->writePendingValues();
        },
        nullptr);
}

void
DataStormContract::SessionPrx::detachElements(std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_elements, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_detachElements, iceP_topicId, iceP_elements, context).get();
}

std::future<void>
DataStormContract::SessionPrx::detachElementsAsync(std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_elements, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_detachElements, iceP_topicId, iceP_elements, context);
}

std::function<void()>
DataStormContract::SessionPrx::detachElementsAsync(std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_elements, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_detachElements, iceP_topicId, iceP_elements, context);
}

void
DataStormContract::SessionPrx::_iceI_detachElements(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const ::Ice::LongSeq& iceP_elements, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "detachElements";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_elements);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::initSamples(std::int64_t iceP_topicId, const DataSamplesSeq& iceP_samples, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_initSamples, iceP_topicId, iceP_samples, context).get();
}

std::future<void>
DataStormContract::SessionPrx::initSamplesAsync(std::int64_t iceP_topicId, const DataSamplesSeq& iceP_samples, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_initSamples, iceP_topicId, iceP_samples, context);
}

std::function<void()>
DataStormContract::SessionPrx::initSamplesAsync(std::int64_t iceP_topicId, const DataSamplesSeq& iceP_samples, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_initSamples, iceP_topicId, iceP_samples, context);
}

void
DataStormContract::SessionPrx::_iceI_initSamples(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, const DataSamplesSeq& iceP_samples, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "initSamples";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_samples);
        },
        nullptr);
}

void
DataStormContract::SessionPrx::disconnected(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_disconnected, context).get();
}

std::future<void>
DataStormContract::SessionPrx::disconnectedAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SessionPrx::_iceI_disconnected, context);
}

std::function<void()>
DataStormContract::SessionPrx::disconnectedAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SessionPrx::_iceI_disconnected, context);
}

void
DataStormContract::SessionPrx::_iceI_disconnected(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "disconnected";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        nullptr,
        nullptr);
}

const char*
DataStormContract::SessionPrx::ice_staticId() noexcept
{
    return "::DataStormContract::Session";
}

DataStormContract::PublisherSessionPrx::~PublisherSessionPrx() = default;

const char*
DataStormContract::PublisherSessionPrx::ice_staticId() noexcept
{
    return "::DataStormContract::PublisherSession";
}

DataStormContract::SubscriberSessionPrx::~SubscriberSessionPrx() = default;

void
DataStormContract::SubscriberSessionPrx::s(std::int64_t iceP_topicId, std::int64_t iceP_elementId, const DataSample& iceP_sample, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &SubscriberSessionPrx::_iceI_s, iceP_topicId, iceP_elementId, iceP_sample, context).get();
}

std::future<void>
DataStormContract::SubscriberSessionPrx::sAsync(std::int64_t iceP_topicId, std::int64_t iceP_elementId, const DataSample& iceP_sample, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &SubscriberSessionPrx::_iceI_s, iceP_topicId, iceP_elementId, iceP_sample, context);
}

std::function<void()>
DataStormContract::SubscriberSessionPrx::sAsync(std::int64_t iceP_topicId, std::int64_t iceP_elementId, const DataSample& iceP_sample, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::SubscriberSessionPrx::_iceI_s, iceP_topicId, iceP_elementId, iceP_sample, context);
}

void
DataStormContract::SubscriberSessionPrx::_iceI_s(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::int64_t iceP_topicId, std::int64_t iceP_elementId, const DataSample& iceP_sample, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "s";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topicId, iceP_elementId, iceP_sample);
        },
        nullptr);
}

const char*
DataStormContract::SubscriberSessionPrx::ice_staticId() noexcept
{
    return "::DataStormContract::SubscriberSession";
}

DataStormContract::NodePrx::~NodePrx() = default;

void
DataStormContract::NodePrx::initiateCreateSession(const std::optional<NodePrx>& iceP_publisher, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_initiateCreateSession, iceP_publisher, context).get();
}

std::future<void>
DataStormContract::NodePrx::initiateCreateSessionAsync(const std::optional<NodePrx>& iceP_publisher, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &NodePrx::_iceI_initiateCreateSession, iceP_publisher, context);
}

std::function<void()>
DataStormContract::NodePrx::initiateCreateSessionAsync(const std::optional<NodePrx>& iceP_publisher, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::NodePrx::_iceI_initiateCreateSession, iceP_publisher, context);
}

void
DataStormContract::NodePrx::_iceI_initiateCreateSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const std::optional<NodePrx>& iceP_publisher, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "initiateCreateSession";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_publisher);
        },
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const SessionCreationException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
DataStormContract::NodePrx::createSession(const std::optional<NodePrx>& iceP_subscriber, const std::optional<SubscriberSessionPrx>& iceP_session, bool iceP_fromRelay, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_createSession, iceP_subscriber, iceP_session, iceP_fromRelay, context).get();
}

std::future<void>
DataStormContract::NodePrx::createSessionAsync(const std::optional<NodePrx>& iceP_subscriber, const std::optional<SubscriberSessionPrx>& iceP_session, bool iceP_fromRelay, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &NodePrx::_iceI_createSession, iceP_subscriber, iceP_session, iceP_fromRelay, context);
}

std::function<void()>
DataStormContract::NodePrx::createSessionAsync(const std::optional<NodePrx>& iceP_subscriber, const std::optional<SubscriberSessionPrx>& iceP_session, bool iceP_fromRelay, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::NodePrx::_iceI_createSession, iceP_subscriber, iceP_session, iceP_fromRelay, context);
}

void
DataStormContract::NodePrx::_iceI_createSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const std::optional<NodePrx>& iceP_subscriber, const std::optional<SubscriberSessionPrx>& iceP_session, bool iceP_fromRelay, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "createSession";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_subscriber, iceP_session, iceP_fromRelay);
        },
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const SessionCreationException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

void
DataStormContract::NodePrx::confirmCreateSession(const std::optional<NodePrx>& iceP_publisher, const std::optional<PublisherSessionPrx>& iceP_session, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_confirmCreateSession, iceP_publisher, iceP_session, context).get();
}

std::future<void>
DataStormContract::NodePrx::confirmCreateSessionAsync(const std::optional<NodePrx>& iceP_publisher, const std::optional<PublisherSessionPrx>& iceP_session, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &NodePrx::_iceI_confirmCreateSession, iceP_publisher, iceP_session, context);
}

std::function<void()>
DataStormContract::NodePrx::confirmCreateSessionAsync(const std::optional<NodePrx>& iceP_publisher, const std::optional<PublisherSessionPrx>& iceP_session, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::NodePrx::_iceI_confirmCreateSession, iceP_publisher, iceP_session, context);
}

void
DataStormContract::NodePrx::_iceI_confirmCreateSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const std::optional<NodePrx>& iceP_publisher, const std::optional<PublisherSessionPrx>& iceP_session, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "confirmCreateSession";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_publisher, iceP_session);
        },
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const SessionCreationException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

const char*
DataStormContract::NodePrx::ice_staticId() noexcept
{
    return "::DataStormContract::Node";
}

DataStormContract::LookupPrx::~LookupPrx() = default;

void
DataStormContract::LookupPrx::announceTopicReader(std::string_view iceP_topic, const std::optional<NodePrx>& iceP_subscriber, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &LookupPrx::_iceI_announceTopicReader, iceP_topic, iceP_subscriber, context).get();
}

std::future<void>
DataStormContract::LookupPrx::announceTopicReaderAsync(std::string_view iceP_topic, const std::optional<NodePrx>& iceP_subscriber, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &LookupPrx::_iceI_announceTopicReader, iceP_topic, iceP_subscriber, context);
}

std::function<void()>
DataStormContract::LookupPrx::announceTopicReaderAsync(std::string_view iceP_topic, const std::optional<NodePrx>& iceP_subscriber, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::LookupPrx::_iceI_announceTopicReader, iceP_topic, iceP_subscriber, context);
}

void
DataStormContract::LookupPrx::_iceI_announceTopicReader(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::string_view iceP_topic, const std::optional<NodePrx>& iceP_subscriber, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "announceTopicReader";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Idempotent,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topic, iceP_subscriber);
        },
        nullptr);
}

void
DataStormContract::LookupPrx::announceTopicWriter(std::string_view iceP_topic, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &LookupPrx::_iceI_announceTopicWriter, iceP_topic, iceP_node, context).get();
}

std::future<void>
DataStormContract::LookupPrx::announceTopicWriterAsync(std::string_view iceP_topic, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &LookupPrx::_iceI_announceTopicWriter, iceP_topic, iceP_node, context);
}

std::function<void()>
DataStormContract::LookupPrx::announceTopicWriterAsync(std::string_view iceP_topic, const std::optional<NodePrx>& iceP_node, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::LookupPrx::_iceI_announceTopicWriter, iceP_topic, iceP_node, context);
}

void
DataStormContract::LookupPrx::_iceI_announceTopicWriter(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, std::string_view iceP_topic, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "announceTopicWriter";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Idempotent,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_topic, iceP_node);
        },
        nullptr);
}

void
DataStormContract::LookupPrx::announceTopics(const ::Ice::StringSeq& iceP_readers, const ::Ice::StringSeq& iceP_writers, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &LookupPrx::_iceI_announceTopics, iceP_readers, iceP_writers, iceP_node, context).get();
}

std::future<void>
DataStormContract::LookupPrx::announceTopicsAsync(const ::Ice::StringSeq& iceP_readers, const ::Ice::StringSeq& iceP_writers, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &LookupPrx::_iceI_announceTopics, iceP_readers, iceP_writers, iceP_node, context);
}

std::function<void()>
DataStormContract::LookupPrx::announceTopicsAsync(const ::Ice::StringSeq& iceP_readers, const ::Ice::StringSeq& iceP_writers, const std::optional<NodePrx>& iceP_node, std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::LookupPrx::_iceI_announceTopics, iceP_readers, iceP_writers, iceP_node, context);
}

void
DataStormContract::LookupPrx::_iceI_announceTopics(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::StringSeq& iceP_readers, const ::Ice::StringSeq& iceP_writers, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "announceTopics";

    outAsync->invoke(
        operationName,
        Ice::OperationMode::Idempotent,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_readers, iceP_writers, iceP_node);
        },
        nullptr);
}

std::optional<::DataStormContract::NodePrx>
DataStormContract::LookupPrx::createSession(const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<NodePrx>>(true, this, &LookupPrx::_iceI_createSession, iceP_node, context).get();
}

std::future<std::optional<::DataStormContract::NodePrx>>
DataStormContract::LookupPrx::createSessionAsync(const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<NodePrx>>(false, this, &LookupPrx::_iceI_createSession, iceP_node, context);
}

std::function<void()>
DataStormContract::LookupPrx::createSessionAsync(const std::optional<NodePrx>& iceP_node, std::function<void(std::optional<::DataStormContract::NodePrx>)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<std::optional<NodePrx>>(std::move(response), std::move(exception), std::move(sent), this, &DataStormContract::LookupPrx::_iceI_createSession, iceP_node, context);
}

void
DataStormContract::LookupPrx::_iceI_createSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<NodePrx>>>& outAsync, const std::optional<NodePrx>& iceP_node, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "createSession";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node);
        },
        nullptr);
}

const char*
DataStormContract::LookupPrx::ice_staticId() noexcept
{
    return "::DataStormContract::Lookup";
}

void
DataStormContract::DataSample::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "id = ", this->id);
    Ice::print(os << ", keyId = ", this->keyId);
    Ice::print(os << ", keyValue = ", this->keyValue);
    Ice::print(os << ", timestamp = ", this->timestamp);
    Ice::print(os << ", tag = ", this->tag);
    Ice::print(os << ", event = ", this->event);
    Ice::print(os << ", value = ", this->value);
}

std::ostream&
DataStormContract::operator<<(std::ostream& os, const ::DataStormContract::DataSample& value)
{
    os << "DataStormContract::DataSample{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

void
DataStormContract::DataSamples::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "id = ", this->id);
    Ice::print(os << ", samples = ", this->samples);
}

void
DataStormContract::ElementInfo::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "id = ", this->id);
    Ice::print(os << ", name = ", this->name);
    Ice::print(os << ", value = ", this->value);
}

void
DataStormContract::TopicInfo::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "name = ", this->name);
    Ice::print(os << ", ids = ", this->ids);
}

void
DataStormContract::TopicSpec::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "id = ", this->id);
    Ice::print(os << ", name = ", this->name);
    Ice::print(os << ", elements = ", this->elements);
    Ice::print(os << ", tags = ", this->tags);
}

void
DataStormContract::FilterInfo::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "name = ", this->name);
    Ice::print(os << ", criteria = ", this->criteria);
}

std::ostream&
DataStormContract::operator<<(std::ostream& os, const ::DataStormContract::FilterInfo& value)
{
    os << "DataStormContract::FilterInfo{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

const char*
DataStormContract::ElementConfig::ice_staticId() noexcept
{
    return "::DataStormContract::ElementConfig";
}

const char*
DataStormContract::ElementConfig::ice_id() const noexcept
{
    return ice_staticId();
}

void
DataStormContract::ElementConfig::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "facet = ", this->facet);
    Ice::print(os << ", sampleFilter = ", this->sampleFilter);
    Ice::print(os << ", name = ", this->name);
    Ice::print(os << ", priority = ", this->priority);
    Ice::print(os << ", sampleCount = ", this->sampleCount);
    Ice::print(os << ", sampleLifetime = ", this->sampleLifetime);
    Ice::print(os << ", clearHistory = ", this->clearHistory);
}

Ice::ValuePtr
DataStormContract::ElementConfig::_iceCloneImpl() const
{
    return CloneEnabler<ElementConfig>::clone(*this);
}

void
DataStormContract::ElementConfig::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll({1, 2, 3, 4, 10, 11, 12}, this->facet, this->sampleFilter, this->name, this->priority, this->sampleCount, this->sampleLifetime, this->clearHistory);
    ostr->endSlice();
}

void
DataStormContract::ElementConfig::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll({1, 2, 3, 4, 10, 11, 12}, this->facet, this->sampleFilter, this->name, this->priority, this->sampleCount, this->sampleLifetime, this->clearHistory);
    istr->endSlice();
}

void
DataStormContract::ElementData::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "id = ", this->id);
    Ice::print(os << ", config = ", this->config);
    Ice::print(os << ", lastIds = ", this->lastIds);
}

void
DataStormContract::ElementSpec::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "elements = ", this->elements);
    Ice::print(os << ", id = ", this->id);
    Ice::print(os << ", name = ", this->name);
    Ice::print(os << ", value = ", this->value);
    Ice::print(os << ", peerId = ", this->peerId);
    Ice::print(os << ", peerName = ", this->peerName);
}

void
DataStormContract::ElementDataAck::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "id = ", this->id);
    Ice::print(os << ", config = ", this->config);
    Ice::print(os << ", lastIds = ", this->lastIds);
    Ice::print(os << ", samples = ", this->samples);
    Ice::print(os << ", peerId = ", this->peerId);
}

void
DataStormContract::ElementSpecAck::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "elements = ", this->elements);
    Ice::print(os << ", id = ", this->id);
    Ice::print(os << ", name = ", this->name);
    Ice::print(os << ", value = ", this->value);
    Ice::print(os << ", peerId = ", this->peerId);
    Ice::print(os << ", peerName = ", this->peerName);
}

void
DataStormContract::SessionCreationException::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "error = ", this->error);
}

const char*
DataStormContract::SessionCreationException::ice_staticId() noexcept
{
    return "::DataStormContract::SessionCreationException";
}

const char*
DataStormContract::SessionCreationException::ice_id() const noexcept
{
    return ice_staticId();
}

void
DataStormContract::SessionCreationException::ice_throw() const
{
    throw *this;
}

void
DataStormContract::SessionCreationException::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->error);
    ostr->endSlice();
}

void
DataStormContract::SessionCreationException::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->error);
    istr->endSlice();
}

void
DataStormContract::Session::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 15> allOperations{"announceElements", "announceTopics", "attachElements", "attachElementsAck", "attachTags", "attachTopic", "detachElements", "detachTags", "detachTopic", "disconnected", "ice_id", "ice_ids", "ice_isA", "ice_ping", "initSamples"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_announceElements(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_announceTopics(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_attachElements(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_attachElementsAck(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_attachTags(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_attachTopic(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_detachElements(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_detachTags(request, std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_detachTopic(request, std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_disconnected(request, std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_initSamples(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
DataStormContract::Session::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::DataStormContract::Session", "::Ice::Object"};
    return allTypeIds;
}

std::string
DataStormContract::Session::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

void
DataStormContract::Session::_iceD_announceTopics(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    TopicInfoSeq iceP_topics;
    bool iceP_initialize;
    istr->readAll(iceP_topics, iceP_initialize);
    istr->endEncapsulation();
    this->announceTopics(std::move(iceP_topics), iceP_initialize, request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_attachTopic(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    TopicSpec iceP_topic;
    istr->readAll(iceP_topic);
    istr->endEncapsulation();
    this->attachTopic(std::move(iceP_topic), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_detachTopic(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    istr->readAll(iceP_topicId);
    istr->endEncapsulation();
    this->detachTopic(iceP_topicId, request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_attachTags(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    ElementInfoSeq iceP_tags;
    bool iceP_initialize;
    istr->readAll(iceP_topicId, iceP_tags, iceP_initialize);
    istr->endEncapsulation();
    this->attachTags(iceP_topicId, std::move(iceP_tags), iceP_initialize, request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_detachTags(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    ::Ice::LongSeq iceP_tags;
    istr->readAll(iceP_topicId, iceP_tags);
    istr->endEncapsulation();
    this->detachTags(iceP_topicId, std::move(iceP_tags), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_announceElements(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    ElementInfoSeq iceP_elements;
    istr->readAll(iceP_topicId, iceP_elements);
    istr->endEncapsulation();
    this->announceElements(iceP_topicId, std::move(iceP_elements), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_attachElements(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    ElementSpecSeq iceP_elements;
    bool iceP_initialize;
    istr->readAll(iceP_topicId, iceP_elements, iceP_initialize);
    istr->readPendingValues();
    istr->endEncapsulation();
    this->attachElements(iceP_topicId, std::move(iceP_elements), iceP_initialize, request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_attachElementsAck(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    ElementSpecAckSeq iceP_elements;
    istr->readAll(iceP_topicId, iceP_elements);
    istr->readPendingValues();
    istr->endEncapsulation();
    this->attachElementsAck(iceP_topicId, std::move(iceP_elements), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_detachElements(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    ::Ice::LongSeq iceP_elements;
    istr->readAll(iceP_topicId, iceP_elements);
    istr->endEncapsulation();
    this->detachElements(iceP_topicId, std::move(iceP_elements), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_initSamples(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    DataSamplesSeq iceP_samples;
    istr->readAll(iceP_topicId, iceP_samples);
    istr->endEncapsulation();
    this->initSamples(iceP_topicId, std::move(iceP_samples), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Session::_iceD_disconnected(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    request.inputStream().skipEmptyEncapsulation();
    this->disconnected(request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

const char*
DataStormContract::Session::ice_staticId() noexcept
{
    return "::DataStormContract::Session";
}

void
DataStormContract::PublisherSession::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 15> allOperations{"announceElements", "announceTopics", "attachElements", "attachElementsAck", "attachTags", "attachTopic", "detachElements", "detachTags", "detachTopic", "disconnected", "ice_id", "ice_ids", "ice_isA", "ice_ping", "initSamples"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_announceElements(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_announceTopics(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_attachElements(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_attachElementsAck(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_attachTags(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_attachTopic(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_detachElements(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_detachTags(request, std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_detachTopic(request, std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_disconnected(request, std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_initSamples(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
DataStormContract::PublisherSession::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::DataStormContract::PublisherSession", "::DataStormContract::Session", "::Ice::Object"};
    return allTypeIds;
}

std::string
DataStormContract::PublisherSession::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

const char*
DataStormContract::PublisherSession::ice_staticId() noexcept
{
    return "::DataStormContract::PublisherSession";
}

void
DataStormContract::SubscriberSession::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 16> allOperations{"announceElements", "announceTopics", "attachElements", "attachElementsAck", "attachTags", "attachTopic", "detachElements", "detachTags", "detachTopic", "disconnected", "ice_id", "ice_ids", "ice_isA", "ice_ping", "initSamples", "s"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_announceElements(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_announceTopics(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_attachElements(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_attachElementsAck(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_attachTags(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_attachTopic(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_detachElements(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_detachTags(request, std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_detachTopic(request, std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_disconnected(request, std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_initSamples(request, std::move(sendResponse));
            break;
        }
        case 15:
        {
            _iceD_s(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
DataStormContract::SubscriberSession::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::DataStormContract::Session", "::DataStormContract::SubscriberSession", "::Ice::Object"};
    return allTypeIds;
}

std::string
DataStormContract::SubscriberSession::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

void
DataStormContract::SubscriberSession::_iceD_s(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::int64_t iceP_topicId;
    std::int64_t iceP_elementId;
    DataSample iceP_sample;
    istr->readAll(iceP_topicId, iceP_elementId, iceP_sample);
    istr->endEncapsulation();
    this->s(iceP_topicId, iceP_elementId, std::move(iceP_sample), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

const char*
DataStormContract::SubscriberSession::ice_staticId() noexcept
{
    return "::DataStormContract::SubscriberSession";
}

void
DataStormContract::Node::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 7> allOperations{"confirmCreateSession", "createSession", "ice_id", "ice_ids", "ice_isA", "ice_ping", "initiateCreateSession"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_confirmCreateSession(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_createSession(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_initiateCreateSession(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
DataStormContract::Node::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::DataStormContract::Node", "::Ice::Object"};
    return allTypeIds;
}

std::string
DataStormContract::Node::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

void
DataStormContract::Node::_iceD_initiateCreateSession(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::optional<NodePrx> iceP_publisher;
    istr->readAll(iceP_publisher);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->initiateCreateSessionAsync(std::move(iceP_publisher), [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}

void
DataStormContract::Node::_iceD_createSession(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::optional<NodePrx> iceP_subscriber;
    std::optional<SubscriberSessionPrx> iceP_session;
    bool iceP_fromRelay;
    istr->readAll(iceP_subscriber, iceP_session, iceP_fromRelay);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->createSessionAsync(std::move(iceP_subscriber), std::move(iceP_session), iceP_fromRelay, [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}

void
DataStormContract::Node::_iceD_confirmCreateSession(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::optional<NodePrx> iceP_publisher;
    std::optional<PublisherSessionPrx> iceP_session;
    istr->readAll(iceP_publisher, iceP_session);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->confirmCreateSessionAsync(std::move(iceP_publisher), std::move(iceP_session), [responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}

const char*
DataStormContract::Node::ice_staticId() noexcept
{
    return "::DataStormContract::Node";
}

void
DataStormContract::Lookup::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 8> allOperations{"announceTopicReader", "announceTopicWriter", "announceTopics", "createSession", "ice_id", "ice_ids", "ice_isA", "ice_ping"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_announceTopicReader(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_announceTopicWriter(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_announceTopics(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_createSession(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
DataStormContract::Lookup::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::DataStormContract::Lookup", "::Ice::Object"};
    return allTypeIds;
}

std::string
DataStormContract::Lookup::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

void
DataStormContract::Lookup::_iceD_announceTopicReader(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::string iceP_topic;
    std::optional<NodePrx> iceP_subscriber;
    istr->readAll(iceP_topic, iceP_subscriber);
    istr->endEncapsulation();
    this->announceTopicReader(std::move(iceP_topic), std::move(iceP_subscriber), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Lookup::_iceD_announceTopicWriter(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::string iceP_topic;
    std::optional<NodePrx> iceP_node;
    istr->readAll(iceP_topic, iceP_node);
    istr->endEncapsulation();
    this->announceTopicWriter(std::move(iceP_topic), std::move(iceP_node), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Lookup::_iceD_announceTopics(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::Ice::StringSeq iceP_readers;
    ::Ice::StringSeq iceP_writers;
    std::optional<NodePrx> iceP_node;
    istr->readAll(iceP_readers, iceP_writers, iceP_node);
    istr->endEncapsulation();
    this->announceTopics(std::move(iceP_readers), std::move(iceP_writers), std::move(iceP_node), request.current());
    sendResponse(Ice::makeEmptyOutgoingResponse(request.current()));
}

void
DataStormContract::Lookup::_iceD_createSession(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::optional<NodePrx> iceP_node;
    istr->readAll(iceP_node);
    istr->endEncapsulation();
    const std::optional<NodePrx> ret = this->createSession(std::move(iceP_node), request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}

const char*
DataStormContract::Lookup::ice_staticId() noexcept
{
    return "::DataStormContract::Lookup";
}
