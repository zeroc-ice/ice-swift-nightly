// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'Contract.ice'.</auto-generated>
// clang-format off

#ifndef DataStorm_Contract_h_
#define DataStorm_Contract_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <DataStorm/SampleEvent.h>
#include <deque>

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

// NOLINTBEGIN(modernize-concat-nested-namespaces)

namespace DataStormContract
{
    /// Defines policies for clearing the data sample history of a reader in response to sample events.
    enum class ClearHistoryPolicy : std::uint8_t
    {
        /// The reader clears its history when a new data sample is added.
        OnAdd,

        /// The reader clears its history when a data sample is removed.
        OnRemove,

        /// The reader clears its history when any data sample event occurs.
        OnAll,

        /// The reader clears its history for all data sample events except for partial update events.
        OnAllExceptPartialUpdate,

        /// The reader never clears its history.
        Never
    };

    /// Outputs the enumerator name or underlying value of a ClearHistoryPolicy to a stream.
    /// @param os The output stream.
    /// @param value The value to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, ClearHistoryPolicy value);

    using LongLongDict = std::map<std::int64_t, std::int64_t>;

    struct DataSample;

    using DataSampleSeq = std::deque<DataSample>;

    struct DataSamples;

    using DataSamplesSeq = std::vector<DataSamples>;

    struct ElementInfo;

    using ElementInfoSeq = std::vector<ElementInfo>;

    struct TopicInfo;

    /// Represents a sequence of active topics used for transmitting topic information between publisher and subscriber
    /// sessions.
    /// @see Session#announceTopics
    using TopicInfoSeq = std::vector<TopicInfo>;

    struct TopicSpec;

    struct FilterInfo;

    class ElementConfig;

    /// A shared pointer to an ElementConfig.
    using ElementConfigPtr = std::shared_ptr<ElementConfig>;

    struct ElementData;

    using ElementDataSeq = std::vector<ElementData>;

    struct ElementSpec;

    using ElementSpecSeq = std::vector<ElementSpec>;

    struct ElementDataAck;

    using ElementDataAckSeq = std::vector<ElementDataAck>;

    struct ElementSpecAck;

    using ElementSpecAckSeq = std::vector<ElementSpecAck>;

    class SessionPrx;

    class PublisherSessionPrx;

    class SubscriberSessionPrx;

    /// The reason for the session creation failure.
    enum class SessionCreationError : std::uint8_t
    {
        /// The session is already connected.
        AlreadyConnected,

        /// Node is shutting down.
        NodeShutdown,

        /// A confirmation was received for a session that doesn't exist.
        SessionNotFound,

        /// The session creation failed due to an internal error.
        Internal
    };

    /// Outputs the enumerator name or underlying value of a SessionCreationError to a stream.
    /// @param os The output stream.
    /// @param value The value to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, SessionCreationError value);

    class NodePrx;

    class LookupPrx;
}

namespace DataStormContract
{
    /// The base interface for publisher and subscriber sessions.
    ///
    /// This interface specifies the operations for communication between publisher and subscriber sessions.
    /// @see PublisherSession
    /// @see SubscriberSession
    class SessionPrx : public Ice::Proxy<SessionPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        SessionPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        SessionPrx(const SessionPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        SessionPrx(SessionPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~SessionPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        SessionPrx& operator=(const SessionPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        SessionPrx& operator=(SessionPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Announces topics to the peer during session establishment or when adding new topics.
        ///
        /// - During session establishment, announces existing topics.
        /// - For established sessions, announces newly added topics.
        ///
        /// A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
        ///
        /// The receiving peer invokes attachTopic for topics it is interested in.
        /// @param topics The sequence of topics to announce.
        /// @param initialize Currently unused.
        /// @param context The request context.
        /// @see attachTopic
        void announceTopics(const TopicInfoSeq& topics, bool initialize, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announces topics to the peer during session establishment or when adding new topics.
        ///
        /// - During session establishment, announces existing topics.
        /// - For established sessions, announces newly added topics.
        ///
        /// A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
        ///
        /// The receiving peer invokes attachTopic for topics it is interested in.
        /// @param topics The sequence of topics to announce.
        /// @param initialize Currently unused.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        /// @see attachTopic
        [[nodiscard]] std::future<void> announceTopicsAsync(const TopicInfoSeq& topics, bool initialize, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announces topics to the peer during session establishment or when adding new topics.
        ///
        /// - During session establishment, announces existing topics.
        /// - For established sessions, announces newly added topics.
        ///
        /// A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
        ///
        /// The receiving peer invokes attachTopic for topics it is interested in.
        /// @param topics The sequence of topics to announce.
        /// @param initialize Currently unused.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        /// @see attachTopic
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> announceTopicsAsync(const TopicInfoSeq& topics, bool initialize, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_announceTopics(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const TopicInfoSeq&, bool, const Ice::Context&) const;

        /// This operation is invoked if the session is interested in the announced topic. Which occurs when:
        ///
        /// - The session has a reader for a topic that the peer writes, or
        /// - The session has a writer for a topic that the peer reads.
        /// @param topic The TopicSpec describing the topic to attach.
        /// @param context The request context.
        void attachTopic(const TopicSpec& topic, const Ice::Context& context = Ice::noExplicitContext) const;

        /// This operation is invoked if the session is interested in the announced topic. Which occurs when:
        ///
        /// - The session has a reader for a topic that the peer writes, or
        /// - The session has a writer for a topic that the peer reads.
        /// @param topic The TopicSpec describing the topic to attach.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> attachTopicAsync(const TopicSpec& topic, const Ice::Context& context = Ice::noExplicitContext) const;

        /// This operation is invoked if the session is interested in the announced topic. Which occurs when:
        ///
        /// - The session has a reader for a topic that the peer writes, or
        /// - The session has a writer for a topic that the peer reads.
        /// @param topic The TopicSpec describing the topic to attach.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> attachTopicAsync(const TopicSpec& topic, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_attachTopic(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const TopicSpec&, const Ice::Context&) const;

        /// Detaches a topic from the session, typically called when the topic is destroyed.
        ///
        /// This operation is invoked by the topic on listener sessions during its destruction.
        /// @param topicId The unique identifier for the topic to detach.
        /// @param context The request context.
        void detachTopic(std::int64_t topicId, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Detaches a topic from the session, typically called when the topic is destroyed.
        ///
        /// This operation is invoked by the topic on listener sessions during its destruction.
        /// @param topicId The unique identifier for the topic to detach.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> detachTopicAsync(std::int64_t topicId, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Detaches a topic from the session, typically called when the topic is destroyed.
        ///
        /// This operation is invoked by the topic on listener sessions during its destruction.
        /// @param topicId The unique identifier for the topic to detach.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> detachTopicAsync(std::int64_t topicId, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_detachTopic(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const Ice::Context&) const;

        /// Attaches the specified tags to the subscriber of a topic.
        ///
        /// Tags are used to support partial update samples.
        /// @param topicId The unique identifier for the topic to which the tags will be attached.
        /// @param tags The sequence of tags to attach, representing the partial update associations.
        /// @param initialize Indicates whether the tags are being attached during session initialization.
        /// @param context The request context.
        void attachTags(std::int64_t topicId, const ElementInfoSeq& tags, bool initialize, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Attaches the specified tags to the subscriber of a topic.
        ///
        /// Tags are used to support partial update samples.
        /// @param topicId The unique identifier for the topic to which the tags will be attached.
        /// @param tags The sequence of tags to attach, representing the partial update associations.
        /// @param initialize Indicates whether the tags are being attached during session initialization.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> attachTagsAsync(std::int64_t topicId, const ElementInfoSeq& tags, bool initialize, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Attaches the specified tags to the subscriber of a topic.
        ///
        /// Tags are used to support partial update samples.
        /// @param topicId The unique identifier for the topic to which the tags will be attached.
        /// @param tags The sequence of tags to attach, representing the partial update associations.
        /// @param initialize Indicates whether the tags are being attached during session initialization.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> attachTagsAsync(std::int64_t topicId, const ElementInfoSeq& tags, bool initialize, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_attachTags(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const ElementInfoSeq&, bool, const Ice::Context&) const;

        /// Detaches tags from the session.
        /// @param topicId The unique identifier for the topic.
        /// @param tags The sequence of tag identifiers to detach.
        /// @param context The request context.
        void detachTags(std::int64_t topicId, const ::Ice::LongSeq& tags, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Detaches tags from the session.
        /// @param topicId The unique identifier for the topic.
        /// @param tags The sequence of tag identifiers to detach.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> detachTagsAsync(std::int64_t topicId, const ::Ice::LongSeq& tags, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Detaches tags from the session.
        /// @param topicId The unique identifier for the topic.
        /// @param tags The sequence of tag identifiers to detach.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> detachTagsAsync(std::int64_t topicId, const ::Ice::LongSeq& tags, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_detachTags(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const ::Ice::LongSeq&, const Ice::Context&) const;

        /// Announces elements associated with a topic to the peer.
        ///
        /// This operation informs the peer about new data readers or data writers associated with the specified topic.
        /// The receiving peer will invoke `attachElements` for any elements it is interested in.
        ///
        /// - A publisher session announces its data writers.
        /// - A subscriber session announces its data readers.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of elements to announce, representing the data readers or data writers.
        /// @param context The request context.
        /// @see attachElements
        void announceElements(std::int64_t topicId, const ElementInfoSeq& elements, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announces elements associated with a topic to the peer.
        ///
        /// This operation informs the peer about new data readers or data writers associated with the specified topic.
        /// The receiving peer will invoke `attachElements` for any elements it is interested in.
        ///
        /// - A publisher session announces its data writers.
        /// - A subscriber session announces its data readers.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of elements to announce, representing the data readers or data writers.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        /// @see attachElements
        [[nodiscard]] std::future<void> announceElementsAsync(std::int64_t topicId, const ElementInfoSeq& elements, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announces elements associated with a topic to the peer.
        ///
        /// This operation informs the peer about new data readers or data writers associated with the specified topic.
        /// The receiving peer will invoke `attachElements` for any elements it is interested in.
        ///
        /// - A publisher session announces its data writers.
        /// - A subscriber session announces its data readers.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of elements to announce, representing the data readers or data writers.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        /// @see attachElements
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> announceElementsAsync(std::int64_t topicId, const ElementInfoSeq& elements, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_announceElements(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const ElementInfoSeq&, const Ice::Context&) const;

        /// Attaches the specified elements to the subscribers of a topic.
        ///
        /// This operation associates the provided elements, such as keys or filters, with the subscribers of the given
        /// topic.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of `ElementSpec` objects representing the elements to attach.
        /// @param initialize Indicates whether the elements are being attached during session initialization.
        /// @param context The request context.
        void attachElements(std::int64_t topicId, const ElementSpecSeq& elements, bool initialize, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Attaches the specified elements to the subscribers of a topic.
        ///
        /// This operation associates the provided elements, such as keys or filters, with the subscribers of the given
        /// topic.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of `ElementSpec` objects representing the elements to attach.
        /// @param initialize Indicates whether the elements are being attached during session initialization.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> attachElementsAsync(std::int64_t topicId, const ElementSpecSeq& elements, bool initialize, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Attaches the specified elements to the subscribers of a topic.
        ///
        /// This operation associates the provided elements, such as keys or filters, with the subscribers of the given
        /// topic.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of `ElementSpec` objects representing the elements to attach.
        /// @param initialize Indicates whether the elements are being attached during session initialization.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> attachElementsAsync(std::int64_t topicId, const ElementSpecSeq& elements, bool initialize, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_attachElements(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const ElementSpecSeq&, bool, const Ice::Context&) const;

        /// Acknowledges the attachment of elements to the session in response to a previous attachElements request.
        ///
        /// This method confirms that the specified elements, such as keys or filters, have been successfully attached
        /// to the session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of `ElementSpecAck` objects representing the confirmed attachments.
        /// @param context The request context.
        void attachElementsAck(std::int64_t topicId, const ElementSpecAckSeq& elements, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Acknowledges the attachment of elements to the session in response to a previous attachElements request.
        ///
        /// This method confirms that the specified elements, such as keys or filters, have been successfully attached
        /// to the session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of `ElementSpecAck` objects representing the confirmed attachments.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> attachElementsAckAsync(std::int64_t topicId, const ElementSpecAckSeq& elements, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Acknowledges the attachment of elements to the session in response to a previous attachElements request.
        ///
        /// This method confirms that the specified elements, such as keys or filters, have been successfully attached
        /// to the session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of `ElementSpecAck` objects representing the confirmed attachments.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> attachElementsAckAsync(std::int64_t topicId, const ElementSpecAckSeq& elements, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_attachElementsAck(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const ElementSpecAckSeq&, const Ice::Context&) const;

        /// Instructs the peer to detach specific elements associated with a topic.
        ///
        /// This operation is invoked when the specified elements, such as keys or filters, are no longer valid
        /// and should be removed from the peer's session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of element identifiers representing the keys or filters to detach.
        /// @param context The request context.
        void detachElements(std::int64_t topicId, const ::Ice::LongSeq& elements, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Instructs the peer to detach specific elements associated with a topic.
        ///
        /// This operation is invoked when the specified elements, such as keys or filters, are no longer valid
        /// and should be removed from the peer's session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of element identifiers representing the keys or filters to detach.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> detachElementsAsync(std::int64_t topicId, const ::Ice::LongSeq& elements, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Instructs the peer to detach specific elements associated with a topic.
        ///
        /// This operation is invoked when the specified elements, such as keys or filters, are no longer valid
        /// and should be removed from the peer's session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of element identifiers representing the keys or filters to detach.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> detachElementsAsync(std::int64_t topicId, const ::Ice::LongSeq& elements, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_detachElements(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const ::Ice::LongSeq&, const Ice::Context&) const;

        /// Initializes the subscriber with the publisher queued samples for a topic during session establishment.
        /// @param topicId The unique identifier for the topic.
        /// @param samples A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
        /// @param context The request context.
        void initSamples(std::int64_t topicId, const DataSamplesSeq& samples, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initializes the subscriber with the publisher queued samples for a topic during session establishment.
        /// @param topicId The unique identifier for the topic.
        /// @param samples A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> initSamplesAsync(std::int64_t topicId, const DataSamplesSeq& samples, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initializes the subscriber with the publisher queued samples for a topic during session establishment.
        /// @param topicId The unique identifier for the topic.
        /// @param samples A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> initSamplesAsync(std::int64_t topicId, const DataSamplesSeq& samples, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_initSamples(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, const DataSamplesSeq&, const Ice::Context&) const;

        /// Notifies the peer that the session is being disconnected.
        ///
        /// For sessions established through a relay node, this operation is invoked by the relay node if the connection
        /// between the relay node and the target node is lost.
        /// @param context The request context.
        void disconnected(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Notifies the peer that the session is being disconnected.
        ///
        /// For sessions established through a relay node, this operation is invoked by the relay node if the connection
        /// between the relay node and the target node is lost.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> disconnectedAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Notifies the peer that the session is being disconnected.
        ///
        /// For sessions established through a relay node, this operation is invoked by the relay node if the connection
        /// between the relay node and the target node is lost.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> disconnectedAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_disconnected(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::Session"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static SessionPrx _fromReference(IceInternal::ReferencePtr ref) { return SessionPrx{std::move(ref)}; }

    protected:
        /// @private
        SessionPrx() = default;

        /// @private
        explicit SessionPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// The PublisherSession servant is hosted by the publisher node and is accessed by the subscriber node.
    class PublisherSessionPrx : public Ice::Proxy<PublisherSessionPrx, SessionPrx>
    {
    public:
#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        PublisherSessionPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        PublisherSessionPrx(const PublisherSessionPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        PublisherSessionPrx(PublisherSessionPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~PublisherSessionPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        PublisherSessionPrx& operator=(const PublisherSessionPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        PublisherSessionPrx& operator=(PublisherSessionPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::PublisherSession"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static PublisherSessionPrx _fromReference(IceInternal::ReferencePtr ref) { return PublisherSessionPrx{std::move(ref)}; }

    protected:
        /// @private
        PublisherSessionPrx() = default;

        /// @private
        explicit PublisherSessionPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }

#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic pop
#endif
    };

    /// The SubscriberSession servant is hosted by the subscriber node and is accessed by the publisher node.
    class SubscriberSessionPrx : public Ice::Proxy<SubscriberSessionPrx, SessionPrx>
    {
    public:
#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        SubscriberSessionPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        SubscriberSessionPrx(const SubscriberSessionPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        SubscriberSessionPrx(SubscriberSessionPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~SubscriberSessionPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        SubscriberSessionPrx& operator=(const SubscriberSessionPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        SubscriberSessionPrx& operator=(SubscriberSessionPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Queue a sample with the subscribers of the topic element.
        /// @param topicId The unique identifier for the topic to which the sample belong.
        /// @param elementId The unique identifier for the element to which the sample belong.
        /// @param sample The sample to queue.
        /// @param context The request context.
        void s(std::int64_t topicId, std::int64_t elementId, const DataSample& sample, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Queue a sample with the subscribers of the topic element.
        /// @param topicId The unique identifier for the topic to which the sample belong.
        /// @param elementId The unique identifier for the element to which the sample belong.
        /// @param sample The sample to queue.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> sAsync(std::int64_t topicId, std::int64_t elementId, const DataSample& sample, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Queue a sample with the subscribers of the topic element.
        /// @param topicId The unique identifier for the topic to which the sample belong.
        /// @param elementId The unique identifier for the element to which the sample belong.
        /// @param sample The sample to queue.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> sAsync(std::int64_t topicId, std::int64_t elementId, const DataSample& sample, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_s(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int64_t, std::int64_t, const DataSample&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::SubscriberSession"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static SubscriberSessionPrx _fromReference(IceInternal::ReferencePtr ref) { return SubscriberSessionPrx{std::move(ref)}; }

    protected:
        /// @private
        SubscriberSessionPrx() = default;

        /// @private
        explicit SubscriberSessionPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }

#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic pop
#endif
    };

    /// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
    ///
    /// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
    /// publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
    /// initiates the creation of a subscriber session.
    ///
    /// The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
    /// PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
    /// publisher node through a SubscriberSession proxy.
    class NodePrx : public Ice::Proxy<NodePrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        NodePrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        NodePrx(const NodePrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        NodePrx(NodePrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~NodePrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        NodePrx& operator=(const NodePrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        NodePrx& operator=(NodePrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        /// reader for which this node has a corresponding topic writer.
        /// @param publisher The publisher node initiating the session. The proxy is never null.
        /// @param context The request context.
        /// @throws DataStormContract::SessionCreationException Thrown when the session cannot be created.
        /// @see Lookup::announceTopicReader
        void initiateCreateSession(const std::optional<NodePrx>& publisher, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        /// reader for which this node has a corresponding topic writer.
        /// @param publisher The publisher node initiating the session. The proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        /// @see Lookup::announceTopicReader
        [[nodiscard]] std::future<void> initiateCreateSessionAsync(const std::optional<NodePrx>& publisher, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        /// reader for which this node has a corresponding topic writer.
        /// @param publisher The publisher node initiating the session. The proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        /// @see Lookup::announceTopicReader
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> initiateCreateSessionAsync(const std::optional<NodePrx>& publisher, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_initiateCreateSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const std::optional<NodePrx>&, const Ice::Context&) const;

        /// Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
        /// publisher node in one of the following scenarios:
        ///
        /// - The subscriber has received a topic writer announcement from the publisher and has a matching topic
        /// reader.
        /// - The publisher node has previously sent a initiateCreateSession request.
        ///
        /// The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
        /// to continue session establishment. If an active session already exists with the subscriber node, the
        /// request is ignored.
        /// @param subscriber The subscriber node initiating the session. This proxy is never null.
        /// @param session The subscriber session being created. This proxy is never null.
        /// @param fromRelay Indicates whether the session is being created from a relay node.
        /// @param context The request context.
        /// @throws DataStormContract::SessionCreationException Thrown when the session cannot be created.
        void createSession(const std::optional<NodePrx>& subscriber, const std::optional<SubscriberSessionPrx>& session, bool fromRelay, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
        /// publisher node in one of the following scenarios:
        ///
        /// - The subscriber has received a topic writer announcement from the publisher and has a matching topic
        /// reader.
        /// - The publisher node has previously sent a initiateCreateSession request.
        ///
        /// The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
        /// to continue session establishment. If an active session already exists with the subscriber node, the
        /// request is ignored.
        /// @param subscriber The subscriber node initiating the session. This proxy is never null.
        /// @param session The subscriber session being created. This proxy is never null.
        /// @param fromRelay Indicates whether the session is being created from a relay node.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> createSessionAsync(const std::optional<NodePrx>& subscriber, const std::optional<SubscriberSessionPrx>& session, bool fromRelay, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
        /// publisher node in one of the following scenarios:
        ///
        /// - The subscriber has received a topic writer announcement from the publisher and has a matching topic
        /// reader.
        /// - The publisher node has previously sent a initiateCreateSession request.
        ///
        /// The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
        /// to continue session establishment. If an active session already exists with the subscriber node, the
        /// request is ignored.
        /// @param subscriber The subscriber node initiating the session. This proxy is never null.
        /// @param session The subscriber session being created. This proxy is never null.
        /// @param fromRelay Indicates whether the session is being created from a relay node.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> createSessionAsync(const std::optional<NodePrx>& subscriber, const std::optional<SubscriberSessionPrx>& session, bool fromRelay, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_createSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const std::optional<NodePrx>&, const std::optional<SubscriberSessionPrx>&, bool, const Ice::Context&) const;

        /// Confirm the creation of a publisher session with a node.
        /// @param publisher The publisher node confirming the session. The proxy is never null.
        /// @param session The publisher session being confirmed. The proxy is never null.
        /// @param context The request context.
        /// @throws DataStormContract::SessionCreationException Thrown when the session cannot be created.
        void confirmCreateSession(const std::optional<NodePrx>& publisher, const std::optional<PublisherSessionPrx>& session, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Confirm the creation of a publisher session with a node.
        /// @param publisher The publisher node confirming the session. The proxy is never null.
        /// @param session The publisher session being confirmed. The proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> confirmCreateSessionAsync(const std::optional<NodePrx>& publisher, const std::optional<PublisherSessionPrx>& session, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Confirm the creation of a publisher session with a node.
        /// @param publisher The publisher node confirming the session. The proxy is never null.
        /// @param session The publisher session being confirmed. The proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> confirmCreateSessionAsync(const std::optional<NodePrx>& publisher, const std::optional<PublisherSessionPrx>& session, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_confirmCreateSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const std::optional<NodePrx>&, const std::optional<PublisherSessionPrx>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::Node"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static NodePrx _fromReference(IceInternal::ReferencePtr ref) { return NodePrx{std::move(ref)}; }

    protected:
        /// @private
        NodePrx() = default;

        /// @private
        explicit NodePrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
    /// nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
    /// Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
    class LookupPrx : public Ice::Proxy<LookupPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        LookupPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        LookupPrx(const LookupPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        LookupPrx(LookupPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~LookupPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        LookupPrx& operator=(const LookupPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        LookupPrx& operator=(LookupPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Announce a topic reader.
        /// @param topic The name of the topic.
        /// @param subscriber The node reading the topic. The subscriber proxy is never null.
        /// @param context The request context.
        void announceTopicReader(std::string_view topic, const std::optional<NodePrx>& subscriber, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announce a topic reader.
        /// @param topic The name of the topic.
        /// @param subscriber The node reading the topic. The subscriber proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> announceTopicReaderAsync(std::string_view topic, const std::optional<NodePrx>& subscriber, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announce a topic reader.
        /// @param topic The name of the topic.
        /// @param subscriber The node reading the topic. The subscriber proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> announceTopicReaderAsync(std::string_view topic, const std::optional<NodePrx>& subscriber, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_announceTopicReader(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::string_view, const std::optional<NodePrx>&, const Ice::Context&) const;

        /// Announce a topic writer.
        /// @param topic The name of the topic.
        /// @param node The node writing the topic. The proxy is never null.
        /// @param context The request context.
        void announceTopicWriter(std::string_view topic, const std::optional<NodePrx>& node, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announce a topic writer.
        /// @param topic The name of the topic.
        /// @param node The node writing the topic. The proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> announceTopicWriterAsync(std::string_view topic, const std::optional<NodePrx>& node, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announce a topic writer.
        /// @param topic The name of the topic.
        /// @param node The node writing the topic. The proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> announceTopicWriterAsync(std::string_view topic, const std::optional<NodePrx>& node, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_announceTopicWriter(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::string_view, const std::optional<NodePrx>&, const Ice::Context&) const;

        /// Announce a set of topic readers and writers.
        /// @param readers A sequence of topic names for readers.
        /// @param writers A sequence of topic names for writers.
        /// @param node The node reading or writing the topics. The proxy is never null.
        /// @param context The request context.
        void announceTopics(const ::Ice::StringSeq& readers, const ::Ice::StringSeq& writers, const std::optional<NodePrx>& node, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announce a set of topic readers and writers.
        /// @param readers A sequence of topic names for readers.
        /// @param writers A sequence of topic names for writers.
        /// @param node The node reading or writing the topics. The proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> announceTopicsAsync(const ::Ice::StringSeq& readers, const ::Ice::StringSeq& writers, const std::optional<NodePrx>& node, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Announce a set of topic readers and writers.
        /// @param readers A sequence of topic names for readers.
        /// @param writers A sequence of topic names for writers.
        /// @param node The node reading or writing the topics. The proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> announceTopicsAsync(const ::Ice::StringSeq& readers, const ::Ice::StringSeq& writers, const std::optional<NodePrx>& node, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_announceTopics(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const std::optional<NodePrx>&, const Ice::Context&) const;

        /// Establish a connection between this node and the caller node.
        /// @param node The node initiating the connection. The proxy is never null.
        /// @param context The request context.
        /// @return A proxy to this node. The proxy is never null.
        std::optional<NodePrx> createSession(const std::optional<NodePrx>& node, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Establish a connection between this node and the caller node.
        /// @param node The node initiating the connection. The proxy is never null.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - A proxy to this node. The proxy is never null.
        [[nodiscard]] std::future<std::optional<NodePrx>> createSessionAsync(const std::optional<NodePrx>& node, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Establish a connection between this node and the caller node.
        /// @param node The node initiating the connection. The proxy is never null.
        /// @param response The response callback. It accepts:
        /// - A proxy to this node. The proxy is never null.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> createSessionAsync(const std::optional<NodePrx>& node, std::function<void(std::optional<::DataStormContract::NodePrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_createSession(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<NodePrx>>>&, const std::optional<NodePrx>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::Lookup"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static LookupPrx _fromReference(IceInternal::ReferencePtr ref) { return LookupPrx{std::move(ref)}; }

    protected:
        /// @private
        LookupPrx() = default;

        /// @private
        explicit LookupPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };
}

namespace DataStormContract
{
    /// Represents a data sample, the fundamental unit of data exchanged between DataStorm readers and writers.
    struct DataSample
    {
        /// The unique identifier for the sample.
        std::int64_t id;

        /// The unique identifier for the associated key.
        /// A negative value (< 0) indicates a key filter.
        std::int64_t keyId;

        /// The encoded key value, used when keyId < 0 (key filter).
        ::Ice::ByteSeq keyValue;

        /// The timestamp when the sample was written, in milliseconds since the epoch.
        std::int64_t timestamp;

        /// An update tag, used for PartialUpdate sample events.
        std::int64_t tag;

        /// The event type associated with this sample (e.g., Add, Update, PartialUpdate, Remove).
        ::DataStorm::SampleEvent event;

        /// The payload data of the sample.
        ::Ice::ByteSeq value;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int64_t&, const std::int64_t&, const ::Ice::ByteSeq&, const std::int64_t&, const std::int64_t&, const ::DataStorm::SampleEvent&, const ::Ice::ByteSeq&> ice_tuple() const
        {
            return std::tie(id, keyId, keyValue, timestamp, tag, event, value);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a DataSample to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const DataSample& value);

    /// Represents a collection of data samples produced by a specific writer.
    struct DataSamples
    {
        /// The unique identifier for the writer.
        std::int64_t id;

        /// The sequence of samples produced by the writer.
        ::DataStormContract::DataSampleSeq samples;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int64_t&, const ::DataStormContract::DataSampleSeq&> ice_tuple() const
        {
            return std::tie(id, samples);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a DataSamples to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const DataSamples& value);

    /// Provides metadata about an element, such as a key, filter, or tag.
    struct ElementInfo
    {
        /// The unique identifier for the element.
        /// Negative values indicate filter IDs; positive values indicate key or tag IDs.
        std::int64_t id;

        /// The name of the element. Empty for key and tag elements.
        std::string name;

        /// The encoded value of the element.
        ::Ice::ByteSeq value;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int64_t&, const std::string&, const ::Ice::ByteSeq&> ice_tuple() const
        {
            return std::tie(id, name, value);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of an ElementInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const ElementInfo& value);

    /// Contains metadata about a topic, including its name and associated reader/writer IDs.
    /// @see Session#announceTopics
    struct TopicInfo
    {
        /// The name of the topic.
        std::string name;

        /// The list of active topic reader or writer IDs.
        ///
        /// - In a publisher session,  the `ids` field contains the active topic writer IDs.
        /// - In a subscriber session,  the `ids` field contains the active topic reader IDs.
        ::Ice::LongSeq ids;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::string&, const ::Ice::LongSeq&> ice_tuple() const
        {
            return std::tie(name, ids);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a TopicInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const TopicInfo& value);

    /// Provides detailed information about topic readers and topic writers, including its ID, name, keys, filters,
    /// and tags.
    /// @see Session#attachTopic
    struct TopicSpec
    {
        /// The unique identifier for the topic.
        /// The ID uniquely identifies a topic reader or topic writer within a node.
        std::int64_t id;

        /// The name of the topic.
        std::string name;

        /// The topic's keys and filters.
        ::DataStormContract::ElementInfoSeq elements;

        /// The topic update tags.
        ::DataStormContract::ElementInfoSeq tags;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int64_t&, const std::string&, const ::DataStormContract::ElementInfoSeq&, const ::DataStormContract::ElementInfoSeq&> ice_tuple() const
        {
            return std::tie(id, name, elements, tags);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a TopicSpec to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const TopicSpec& value);

    /// Represents a sample filter that specifies which samples should be sent to a data reader.
    struct FilterInfo
    {
        /// The unique name of the filter, used for identification.
        std::string name;

        /// The encoded criteria for instantiating the filter.
        ::Ice::ByteSeq criteria;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::string&, const ::Ice::ByteSeq&> ice_tuple() const
        {
            return std::tie(name, criteria);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a FilterInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const FilterInfo& value);

    /// Represents the configuration of a data reader or data writer, including optional filters and priorities.
    class ElementConfig : public Ice::Value
    {
    public:
        /// Default constructor.
        ElementConfig() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param facet A facet that is used to process the samples when sample filtering is enabled.
        /// @param sampleFilter An optional sample filter associated with the reader.
        /// @param name An optional name for the reader or writer.
        /// @param priority An optional priority for the writer.
        /// @param sampleCount An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
        /// @param sampleLifetime An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the writer or reader sample queue.
        /// @param clearHistory An optional clear history policy that determines when the reader or writer sample history is cleared.
        ElementConfig(std::optional<std::string> facet, std::optional<::DataStormContract::FilterInfo> sampleFilter, std::optional<std::string> name, std::optional<std::int32_t> priority, std::optional<std::int32_t> sampleCount, std::optional<std::int32_t> sampleLifetime, std::optional<::DataStormContract::ClearHistoryPolicy> clearHistory) noexcept :
            facet(std::move(facet)),
            sampleFilter(std::move(sampleFilter)),
            name(std::move(name)),
            priority(priority),
            sampleCount(sampleCount),
            sampleLifetime(sampleLifetime),
            clearHistory(clearHistory)
        {
        }

        /// Gets the type ID of the associated Slice class.
        /// @return The string `"::DataStormContract::ElementConfig"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        /// Creates a tuple with all the fields of this class.
        /// @return A tuple with all the fields of this class.
        [[nodiscard]] std::tuple<const std::optional<std::string>&, const std::optional<::DataStormContract::FilterInfo>&, const std::optional<std::string>&, const std::optional<std::int32_t>&, const std::optional<std::int32_t>&, const std::optional<std::int32_t>&, const std::optional<::DataStormContract::ClearHistoryPolicy>&> ice_tuple() const
        {
            return std::tie(facet, sampleFilter, name, priority, sampleCount, sampleLifetime, clearHistory);
        }

        /// Creates a shallow polymorphic copy of this instance.
        /// @return The cloned value.
        [[nodiscard]] ElementConfigPtr ice_clone() const { return std::static_pointer_cast<ElementConfig>(_iceCloneImpl()); }

        void ice_printFields(std::ostream& os) const override;

        /// A facet that is used to process the samples when sample filtering is enabled.
        std::optional<std::string> facet;

        /// An optional sample filter associated with the reader. Sample filters are specified on the reader side.
        std::optional<::DataStormContract::FilterInfo> sampleFilter;

        /// An optional name for the reader or writer.
        std::optional<std::string> name;

        /// An optional priority for the writer.
        /// See also the `DataStorm.Topic.Priority` property.
        std::optional<std::int32_t> priority;

        /// An optional sample count, specifying the number of samples queued in the writer or reader sample queue.
        /// See also the `DataStorm.Topic.SampleCount` property.
        std::optional<std::int32_t> sampleCount;

        /// An optional lifetime, specified in milliseconds, representing the maximum time samples are kept in the
        /// writer or reader sample queue. See also the `DataStorm.Topic.SampleLifetime` property.
        std::optional<std::int32_t> sampleLifetime;

        /// An optional clear history policy that determines when the reader or writer sample history is cleared.
        /// See also the `DataStorm.Topic.ClearHistory` property.
        std::optional<::DataStormContract::ClearHistoryPolicy> clearHistory;

    protected:
        /// Copy constructor.
        ElementConfig(const ElementConfig&) = default;

        /// @private
        [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

        /// @private
        void _iceWriteImpl(Ice::OutputStream*) const override;

        /// @private
        void _iceReadImpl(Ice::InputStream*) override;
    };

    /// Encapsulates the state and configuration data for a data reader or data writer.
    struct ElementData
    {
        /// The unique identifier for the data reader or data writer.
        std::int64_t id;

        /// The configuration settings for the data reader or data writer.
        ::DataStormContract::ElementConfigPtr config;

        /// A mapping of data writer IDs to the last sample IDs received by the data reader.
        ///
        /// - The key represents the data writer ID.
        /// - The value represents the last sample ID received from the corresponding data writer.
        ::DataStormContract::LongLongDict lastIds;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int64_t&, const ::DataStormContract::ElementConfigPtr&, const ::DataStormContract::LongLongDict&> ice_tuple() const
        {
            return std::tie(id, config, lastIds);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of an ElementData to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const ElementData& value);

    /// Represents detailed information about topic elements, which can be a key or a filter.
    struct ElementSpec
    {
        /// A sequence of data readers and writers associated with the key or filter.
        ::DataStormContract::ElementDataSeq elements;

        /// The unique identifier for the key or filter.
        std::int64_t id;

        /// The name of the filter.
        /// This field is empty if the element is a key.
        std::string name;

        /// The encoded value of the key or filter.
        ::Ice::ByteSeq value;

        /// The unique identifier for the key or filter on the peer.
        std::int64_t peerId;

        /// The name of the filter on the peer.
        /// This field is empty if the element is a key.
        std::string peerName;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const ::DataStormContract::ElementDataSeq&, const std::int64_t&, const std::string&, const ::Ice::ByteSeq&, const std::int64_t&, const std::string&> ice_tuple() const
        {
            return std::tie(elements, id, name, value, peerId, peerName);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of an ElementSpec to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const ElementSpec& value);

    /// Represents an acknowledgment of the attachment of data readers or data writers associated with a key or filter.
    struct ElementDataAck
    {
        /// The unique identifier for the data reader or data writer.
        std::int64_t id;

        /// The configuration settings for the data reader or data writer.
        ::DataStormContract::ElementConfigPtr config;

        /// A mapping of data writer IDs to the last sample IDs received by the data reader.
        ///
        /// - The key represents the data writer ID.
        /// - The value represents the last sample ID received from the corresponding data writer.
        ::DataStormContract::LongLongDict lastIds;

        /// A sequence of samples in the writer's queue, used to initialize the reader.
        ///
        /// - When this struct is sent from a subscriber to a publisher, this field is empty.
        /// - When sent from a publisher to a subscriber, this field contains the queued samples.
        ::DataStormContract::DataSampleSeq samples;

        /// The unique identifier for the peer's data reader or data writer.
        std::int64_t peerId;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int64_t&, const ::DataStormContract::ElementConfigPtr&, const ::DataStormContract::LongLongDict&, const ::DataStormContract::DataSampleSeq&, const std::int64_t&> ice_tuple() const
        {
            return std::tie(id, config, lastIds, samples, peerId);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of an ElementDataAck to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const ElementDataAck& value);

    /// Represents an acknowledgment of the attachment of an element, which can be a key or a filter.
    struct ElementSpecAck
    {
        /// A sequence of acknowledgments for the readers or writers associated with the key or filter.
        ::DataStormContract::ElementDataAckSeq elements;

        /// The unique identifier for the key or filter.
        std::int64_t id;

        /// The name of the filter.
        /// This field is empty if the element is a key.
        std::string name;

        /// The encoded value of the key or filter.
        ::Ice::ByteSeq value;

        /// The unique identifier for the key or filter on the peer.
        std::int64_t peerId;

        /// The name of the filter on the peer.
        /// This field is empty if the element is a key.
        std::string peerName;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const ::DataStormContract::ElementDataAckSeq&, const std::int64_t&, const std::string&, const ::Ice::ByteSeq&, const std::int64_t&, const std::string&> ice_tuple() const
        {
            return std::tie(elements, id, name, value, peerId, peerName);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of an ElementSpecAck to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const ElementSpecAck& value);

    /// Throws when the session cannot be created.
    class SessionCreationException : public Ice::UserException
    {
    public:
        /// Default constructor.
        SessionCreationException() noexcept = default;

        /// One-shot constructor to initialize all data members.
        SessionCreationException(SessionCreationError error) noexcept :
            error(error)
        {
        }

        /// Copy constructor.
        SessionCreationException(const SessionCreationException&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const ::DataStormContract::SessionCreationError&> ice_tuple() const
        {
            return std::tie(error);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::DataStormContract::SessionCreationException"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        ::DataStormContract::SessionCreationError error;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// @cond INTERNAL
    using Ice::Tuple::operator<;
    using Ice::Tuple::operator<=;
    using Ice::Tuple::operator>;
    using Ice::Tuple::operator>=;
    using Ice::Tuple::operator==;
    using Ice::Tuple::operator!=;
    /// @endcond
}

namespace DataStormContract
{
    /// The base interface for publisher and subscriber sessions.
    ///
    /// This interface specifies the operations for communication between publisher and subscriber sessions.
    /// @see PublisherSession
    /// @see SubscriberSession
    class Session : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = SessionPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Announces topics to the peer during session establishment or when adding new topics.
        ///
        /// - During session establishment, announces existing topics.
        /// - For established sessions, announces newly added topics.
        ///
        /// A publisher session announces the topics it writes, and a subscriber session announces the topics it reads.
        ///
        /// The receiving peer invokes attachTopic for topics it is interested in.
        /// @param topics The sequence of topics to announce.
        /// @param initialize Currently unused.
        /// @param current The Current object of the incoming request.
        /// @see attachTopic
        virtual void announceTopics(TopicInfoSeq topics, bool initialize, const Ice::Current& current) = 0;

        /// @private
        void _iceD_announceTopics(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// This operation is invoked if the session is interested in the announced topic. Which occurs when:
        ///
        /// - The session has a reader for a topic that the peer writes, or
        /// - The session has a writer for a topic that the peer reads.
        /// @param topic The TopicSpec describing the topic to attach.
        /// @param current The Current object of the incoming request.
        virtual void attachTopic(TopicSpec topic, const Ice::Current& current) = 0;

        /// @private
        void _iceD_attachTopic(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Detaches a topic from the session, typically called when the topic is destroyed.
        ///
        /// This operation is invoked by the topic on listener sessions during its destruction.
        /// @param topicId The unique identifier for the topic to detach.
        /// @param current The Current object of the incoming request.
        virtual void detachTopic(std::int64_t topicId, const Ice::Current& current) = 0;

        /// @private
        void _iceD_detachTopic(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Attaches the specified tags to the subscriber of a topic.
        ///
        /// Tags are used to support partial update samples.
        /// @param topicId The unique identifier for the topic to which the tags will be attached.
        /// @param tags The sequence of tags to attach, representing the partial update associations.
        /// @param initialize Indicates whether the tags are being attached during session initialization.
        /// @param current The Current object of the incoming request.
        virtual void attachTags(std::int64_t topicId, ElementInfoSeq tags, bool initialize, const Ice::Current& current) = 0;

        /// @private
        void _iceD_attachTags(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Detaches tags from the session.
        /// @param topicId The unique identifier for the topic.
        /// @param tags The sequence of tag identifiers to detach.
        /// @param current The Current object of the incoming request.
        virtual void detachTags(std::int64_t topicId, ::Ice::LongSeq tags, const Ice::Current& current) = 0;

        /// @private
        void _iceD_detachTags(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Announces elements associated with a topic to the peer.
        ///
        /// This operation informs the peer about new data readers or data writers associated with the specified topic.
        /// The receiving peer will invoke `attachElements` for any elements it is interested in.
        ///
        /// - A publisher session announces its data writers.
        /// - A subscriber session announces its data readers.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of elements to announce, representing the data readers or data writers.
        /// @param current The Current object of the incoming request.
        /// @see attachElements
        virtual void announceElements(std::int64_t topicId, ElementInfoSeq elements, const Ice::Current& current) = 0;

        /// @private
        void _iceD_announceElements(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Attaches the specified elements to the subscribers of a topic.
        ///
        /// This operation associates the provided elements, such as keys or filters, with the subscribers of the given
        /// topic.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements The sequence of `ElementSpec` objects representing the elements to attach.
        /// @param initialize Indicates whether the elements are being attached during session initialization.
        /// @param current The Current object of the incoming request.
        virtual void attachElements(std::int64_t topicId, ElementSpecSeq elements, bool initialize, const Ice::Current& current) = 0;

        /// @private
        void _iceD_attachElements(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Acknowledges the attachment of elements to the session in response to a previous attachElements request.
        ///
        /// This method confirms that the specified elements, such as keys or filters, have been successfully attached
        /// to the session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of `ElementSpecAck` objects representing the confirmed attachments.
        /// @param current The Current object of the incoming request.
        virtual void attachElementsAck(std::int64_t topicId, ElementSpecAckSeq elements, const Ice::Current& current) = 0;

        /// @private
        void _iceD_attachElementsAck(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Instructs the peer to detach specific elements associated with a topic.
        ///
        /// This operation is invoked when the specified elements, such as keys or filters, are no longer valid
        /// and should be removed from the peer's session.
        /// @param topicId The unique identifier for the topic to which the elements belong.
        /// @param elements A sequence of element identifiers representing the keys or filters to detach.
        /// @param current The Current object of the incoming request.
        virtual void detachElements(std::int64_t topicId, ::Ice::LongSeq elements, const Ice::Current& current) = 0;

        /// @private
        void _iceD_detachElements(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Initializes the subscriber with the publisher queued samples for a topic during session establishment.
        /// @param topicId The unique identifier for the topic.
        /// @param samples A sequence of `DataSamples` containing the queued samples to initialize the subscriber.
        /// @param current The Current object of the incoming request.
        virtual void initSamples(std::int64_t topicId, DataSamplesSeq samples, const Ice::Current& current) = 0;

        /// @private
        void _iceD_initSamples(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Notifies the peer that the session is being disconnected.
        ///
        /// For sessions established through a relay node, this operation is invoked by the relay node if the connection
        /// between the relay node and the target node is lost.
        /// @param current The Current object of the incoming request.
        virtual void disconnected(const Ice::Current& current) = 0;

        /// @private
        void _iceD_disconnected(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::Session"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Session.
    using SessionPtr = std::shared_ptr<Session>;

    /// The PublisherSession servant is hosted by the publisher node and is accessed by the subscriber node.
    class PublisherSession : public virtual Session
    {
    public:
        /// The associated proxy type.
        using ProxyType = PublisherSessionPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::PublisherSession"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a PublisherSession.
    using PublisherSessionPtr = std::shared_ptr<PublisherSession>;

    /// The SubscriberSession servant is hosted by the subscriber node and is accessed by the publisher node.
    class SubscriberSession : public virtual Session
    {
    public:
        /// The associated proxy type.
        using ProxyType = SubscriberSessionPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Queue a sample with the subscribers of the topic element.
        /// @param topicId The unique identifier for the topic to which the sample belong.
        /// @param elementId The unique identifier for the element to which the sample belong.
        /// @param sample The sample to queue.
        /// @param current The Current object of the incoming request.
        virtual void s(std::int64_t topicId, std::int64_t elementId, DataSample sample, const Ice::Current& current) = 0;

        /// @private
        void _iceD_s(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::SubscriberSession"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a SubscriberSession.
    using SubscriberSessionPtr = std::shared_ptr<SubscriberSession>;

    /// The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
    ///
    /// When a node has a writer for a topic that another node is reading, the node initiates the creation of a
    /// publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
    /// initiates the creation of a subscriber session.
    ///
    /// The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
    /// PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
    /// publisher node through a SubscriberSession proxy.
    class Node : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = NodePrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Initiate the creation of a publisher session with a node, after the target node has announced a topic
        /// reader for which this node has a corresponding topic writer.
        /// @param publisher The publisher node initiating the session. The proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param current The Current object of the incoming request.
        /// @throws DataStormContract::SessionCreationException Thrown when the session cannot be created.
        /// @see Lookup::announceTopicReader
        virtual void initiateCreateSessionAsync(std::optional<NodePrx> publisher, std::function<void()> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// @private
        void _iceD_initiateCreateSession(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Initiates the creation of a subscriber session with a node. The subscriber node sends this request to a
        /// publisher node in one of the following scenarios:
        ///
        /// - The subscriber has received a topic writer announcement from the publisher and has a matching topic
        /// reader.
        /// - The publisher node has previously sent a initiateCreateSession request.
        ///
        /// The publisher node dispatching this request then sends a confirmCreateSession request to the subscriber node
        /// to continue session establishment. If an active session already exists with the subscriber node, the
        /// request is ignored.
        /// @param subscriber The subscriber node initiating the session. This proxy is never null.
        /// @param session The subscriber session being created. This proxy is never null.
        /// @param fromRelay Indicates whether the session is being created from a relay node.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param current The Current object of the incoming request.
        /// @throws DataStormContract::SessionCreationException Thrown when the session cannot be created.
        virtual void createSessionAsync(std::optional<NodePrx> subscriber, std::optional<SubscriberSessionPrx> session, bool fromRelay, std::function<void()> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// @private
        void _iceD_createSession(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Confirm the creation of a publisher session with a node.
        /// @param publisher The publisher node confirming the session. The proxy is never null.
        /// @param session The publisher session being confirmed. The proxy is never null.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param current The Current object of the incoming request.
        /// @throws DataStormContract::SessionCreationException Thrown when the session cannot be created.
        virtual void confirmCreateSessionAsync(std::optional<NodePrx> publisher, std::optional<PublisherSessionPrx> session, std::function<void()> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// @private
        void _iceD_confirmCreateSession(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::Node"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Node.
    using NodePtr = std::shared_ptr<Node>;

    /// The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
    /// nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
    /// Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
    class Lookup : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = LookupPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Announce a topic reader.
        /// @param topic The name of the topic.
        /// @param subscriber The node reading the topic. The subscriber proxy is never null.
        /// @param current The Current object of the incoming request.
        virtual void announceTopicReader(std::string topic, std::optional<NodePrx> subscriber, const Ice::Current& current) = 0;

        /// @private
        void _iceD_announceTopicReader(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Announce a topic writer.
        /// @param topic The name of the topic.
        /// @param node The node writing the topic. The proxy is never null.
        /// @param current The Current object of the incoming request.
        virtual void announceTopicWriter(std::string topic, std::optional<NodePrx> node, const Ice::Current& current) = 0;

        /// @private
        void _iceD_announceTopicWriter(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Announce a set of topic readers and writers.
        /// @param readers A sequence of topic names for readers.
        /// @param writers A sequence of topic names for writers.
        /// @param node The node reading or writing the topics. The proxy is never null.
        /// @param current The Current object of the incoming request.
        virtual void announceTopics(::Ice::StringSeq readers, ::Ice::StringSeq writers, std::optional<NodePrx> node, const Ice::Current& current) = 0;

        /// @private
        void _iceD_announceTopics(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Establish a connection between this node and the caller node.
        /// @param node The node initiating the connection. The proxy is never null.
        /// @param current The Current object of the incoming request.
        /// @return A proxy to this node. The proxy is never null.
        virtual std::optional<NodePrx> createSession(std::optional<NodePrx> node, const Ice::Current& current) = 0;

        /// @private
        void _iceD_createSession(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::DataStormContract::Lookup"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Lookup.
    using LookupPtr = std::shared_ptr<Lookup>;
}

namespace Ice
{
    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::ClearHistoryPolicy>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryEnum;
        static constexpr int minValue = 0;
        static constexpr int maxValue = 4;
        static constexpr int minWireSize = 1;
        static constexpr bool fixedLength = false;
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::DataSample>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 35;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::DataSample>
    {
        /// Unmarshals a ::DataStormContract::DataSample from the input stream.
        static void read(InputStream* istr, ::DataStormContract::DataSample& v)
        {
            istr->readAll(v.id, v.keyId, v.keyValue, v.timestamp, v.tag, v.event, v.value);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::DataSamples>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 9;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::DataSamples>
    {
        /// Unmarshals a ::DataStormContract::DataSamples from the input stream.
        static void read(InputStream* istr, ::DataStormContract::DataSamples& v)
        {
            istr->readAll(v.id, v.samples);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::ElementInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 10;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::ElementInfo>
    {
        /// Unmarshals a ::DataStormContract::ElementInfo from the input stream.
        static void read(InputStream* istr, ::DataStormContract::ElementInfo& v)
        {
            istr->readAll(v.id, v.name, v.value);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::TopicInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 2;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::TopicInfo>
    {
        /// Unmarshals a ::DataStormContract::TopicInfo from the input stream.
        static void read(InputStream* istr, ::DataStormContract::TopicInfo& v)
        {
            istr->readAll(v.name, v.ids);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::TopicSpec>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 11;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::TopicSpec>
    {
        /// Unmarshals a ::DataStormContract::TopicSpec from the input stream.
        static void read(InputStream* istr, ::DataStormContract::TopicSpec& v)
        {
            istr->readAll(v.id, v.name, v.elements, v.tags);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::FilterInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 2;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::FilterInfo>
    {
        /// Unmarshals a ::DataStormContract::FilterInfo from the input stream.
        static void read(InputStream* istr, ::DataStormContract::FilterInfo& v)
        {
            istr->readAll(v.name, v.criteria);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::ElementData>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 10;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::ElementData>
    {
        /// Unmarshals a ::DataStormContract::ElementData from the input stream.
        static void read(InputStream* istr, ::DataStormContract::ElementData& v)
        {
            istr->readAll(v.id, v.config, v.lastIds);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::ElementSpec>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 20;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::ElementSpec>
    {
        /// Unmarshals a ::DataStormContract::ElementSpec from the input stream.
        static void read(InputStream* istr, ::DataStormContract::ElementSpec& v)
        {
            istr->readAll(v.elements, v.id, v.name, v.value, v.peerId, v.peerName);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::ElementDataAck>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 19;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::ElementDataAck>
    {
        /// Unmarshals a ::DataStormContract::ElementDataAck from the input stream.
        static void read(InputStream* istr, ::DataStormContract::ElementDataAck& v)
        {
            istr->readAll(v.id, v.config, v.lastIds, v.samples, v.peerId);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::ElementSpecAck>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 20;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::DataStormContract::ElementSpecAck>
    {
        /// Unmarshals a ::DataStormContract::ElementSpecAck from the input stream.
        static void read(InputStream* istr, ::DataStormContract::ElementSpecAck& v)
        {
            istr->readAll(v.elements, v.id, v.name, v.value, v.peerId, v.peerName);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::DataStormContract::SessionCreationError>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryEnum;
        static constexpr int minValue = 0;
        static constexpr int maxValue = 3;
        static constexpr int minWireSize = 1;
        static constexpr bool fixedLength = false;
    };
    /// @endcond
}

// NOLINTEND(modernize-concat-nested-namespaces)

#include <Ice/PopDisableWarnings.h>
#endif
