// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'Election.ice'.</auto-generated>
// clang-format off

#ifndef Election_h_
#define Election_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include "SubscriberRecord.h"
#include "LLURecord.h"

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

// NOLINTBEGIN(modernize-concat-nested-namespaces)

namespace IceStormElection
{
    struct TopicContent;

    /// A sequence of topic content.
    using TopicContentSeq = std::vector<TopicContent>;

    class ReplicaObserverPrx;

    class TopicManagerSyncPrx;

    /// The node state.
    enum class NodeState : std::uint8_t
    {
        /// The node is inactive and awaiting an election.
        NodeStateInactive,

        /// The node is electing a leader.
        NodeStateElection,

        /// The replica group is reorganizing.
        NodeStateReorganization,

        /// The replica group is active & replicating.
        NodeStateNormal
    };

    /// Outputs the enumerator name or underlying value of a NodeState to a stream.
    /// @param os The output stream.
    /// @param value The value to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, NodeState value);

    class NodePrx;

    struct NodeInfo;

    /// A sequence of node info.
    using NodeInfoSeq = std::vector<NodeInfo>;

    struct GroupInfo;

    /// A sequence of group info.
    using GroupInfoSeq = std::vector<GroupInfo>;

    struct QueryInfo;
}

namespace IceStormElection
{
    /// The replica observer.
    class ReplicaObserverPrx : public Ice::Proxy<ReplicaObserverPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        ReplicaObserverPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        ReplicaObserverPrx(const ReplicaObserverPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        ReplicaObserverPrx(ReplicaObserverPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~ReplicaObserverPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        ReplicaObserverPrx& operator=(const ReplicaObserverPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        ReplicaObserverPrx& operator=(ReplicaObserverPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Initialize the observer.
        /// @param llu The last log update seen by the master.
        /// @param content The topic content.
        /// @param context The request context.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        void init(const LogUpdate& llu, const TopicContentSeq& content, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initialize the observer.
        /// @param llu The last log update seen by the master.
        /// @param content The topic content.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> initAsync(const LogUpdate& llu, const TopicContentSeq& content, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Initialize the observer.
        /// @param llu The last log update seen by the master.
        /// @param content The topic content.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> initAsync(const LogUpdate& llu, const TopicContentSeq& content, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_init(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const LogUpdate&, const TopicContentSeq&, const Ice::Context&) const;

        /// Create the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param context The request context.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        void createTopic(const LogUpdate& llu, std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Create the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> createTopicAsync(const LogUpdate& llu, std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Create the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> createTopicAsync(const LogUpdate& llu, std::string_view name, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_createTopic(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const LogUpdate&, std::string_view, const Ice::Context&) const;

        /// Destroy the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param context The request context.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        void destroyTopic(const LogUpdate& llu, std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Destroy the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> destroyTopicAsync(const LogUpdate& llu, std::string_view name, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Destroy the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> destroyTopicAsync(const LogUpdate& llu, std::string_view name, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_destroyTopic(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const LogUpdate&, std::string_view, const Ice::Context&) const;

        /// Add a subscriber to a topic.
        /// @param llu The log update token.
        /// @param topic The topic name to which to add the subscriber.
        /// @param record The subscriber information.
        /// @param context The request context.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        void addSubscriber(const LogUpdate& llu, std::string_view topic, const ::IceStorm::SubscriberRecord& record, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Add a subscriber to a topic.
        /// @param llu The log update token.
        /// @param topic The topic name to which to add the subscriber.
        /// @param record The subscriber information.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> addSubscriberAsync(const LogUpdate& llu, std::string_view topic, const ::IceStorm::SubscriberRecord& record, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Add a subscriber to a topic.
        /// @param llu The log update token.
        /// @param topic The topic name to which to add the subscriber.
        /// @param record The subscriber information.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> addSubscriberAsync(const LogUpdate& llu, std::string_view topic, const ::IceStorm::SubscriberRecord& record, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_addSubscriber(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const LogUpdate&, std::string_view, const ::IceStorm::SubscriberRecord&, const Ice::Context&) const;

        /// Remove a subscriber from a topic.
        /// @param llu The log update token.
        /// @param topic The topic name.
        /// @param subscribers The identities of the subscribers to remove.
        /// @param context The request context.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        void removeSubscriber(const LogUpdate& llu, std::string_view topic, const ::Ice::IdentitySeq& subscribers, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Remove a subscriber from a topic.
        /// @param llu The log update token.
        /// @param topic The topic name.
        /// @param subscribers The identities of the subscribers to remove.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> removeSubscriberAsync(const LogUpdate& llu, std::string_view topic, const ::Ice::IdentitySeq& subscribers, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Remove a subscriber from a topic.
        /// @param llu The log update token.
        /// @param topic The topic name.
        /// @param subscribers The identities of the subscribers to remove.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> removeSubscriberAsync(const LogUpdate& llu, std::string_view topic, const ::Ice::IdentitySeq& subscribers, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_removeSubscriber(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const LogUpdate&, std::string_view, const ::Ice::IdentitySeq&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStormElection::ReplicaObserver"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static ReplicaObserverPrx _fromReference(IceInternal::ReferencePtr ref) { return ReplicaObserverPrx{std::move(ref)}; }

    protected:
        /// @private
        ReplicaObserverPrx() = default;

        /// @private
        explicit ReplicaObserverPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// Interface used to sync topics.
    class TopicManagerSyncPrx : public Ice::Proxy<TopicManagerSyncPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        TopicManagerSyncPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        TopicManagerSyncPrx(const TopicManagerSyncPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        TopicManagerSyncPrx(TopicManagerSyncPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~TopicManagerSyncPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        TopicManagerSyncPrx& operator=(const TopicManagerSyncPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        TopicManagerSyncPrx& operator=(TopicManagerSyncPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Retrieve the topic content.
        /// @param[out] llu The last log update token.
        /// @param[out] content The topic content.
        /// @param context The request context.
        void getContent(LogUpdate& llu, TopicContentSeq& content, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Retrieve the topic content.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - `llu` The last log update token.
        /// - `content` The topic content.
        [[nodiscard]] std::future<std::tuple<LogUpdate, TopicContentSeq>> getContentAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Retrieve the topic content.
        /// @param response The response callback. It accepts:
        /// - `llu` The last log update token.
        /// - `content` The topic content.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getContentAsync(std::function<void(::IceStormElection::LogUpdate, ::IceStormElection::TopicContentSeq)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getContent(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LogUpdate, TopicContentSeq>>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStormElection::TopicManagerSync"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static TopicManagerSyncPrx _fromReference(IceInternal::ReferencePtr ref) { return TopicManagerSyncPrx{std::move(ref)}; }

    protected:
        /// @private
        TopicManagerSyncPrx() = default;

        /// @private
        explicit TopicManagerSyncPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// A replica node.
    class NodePrx : public Ice::Proxy<NodePrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        NodePrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        NodePrx(const NodePrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        NodePrx(NodePrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~NodePrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        NodePrx& operator=(const NodePrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        NodePrx& operator=(NodePrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Invite the node into a group with the given coordinator and group name.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param context The request context.
        void invitation(std::int32_t j, std::string_view gn, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Invite the node into a group with the given coordinator and group name.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> invitationAsync(std::int32_t j, std::string_view gn, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Invite the node into a group with the given coordinator and group name.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> invitationAsync(std::int32_t j, std::string_view gn, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_invitation(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int32_t, std::string_view, const Ice::Context&) const;

        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param coordinator The proxy to the coordinator.
        /// @param max The highest priority node seen by this replica group.
        /// @param generation The current generation count.
        /// @param context The request context.
        void ready(std::int32_t j, std::string_view gn, const std::optional<Ice::ObjectPrx>& coordinator, std::int32_t max, std::int64_t generation, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param coordinator The proxy to the coordinator.
        /// @param max The highest priority node seen by this replica group.
        /// @param generation The current generation count.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> readyAsync(std::int32_t j, std::string_view gn, const std::optional<Ice::ObjectPrx>& coordinator, std::int32_t max, std::int64_t generation, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param coordinator The proxy to the coordinator.
        /// @param max The highest priority node seen by this replica group.
        /// @param generation The current generation count.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> readyAsync(std::int32_t j, std::string_view gn, const std::optional<Ice::ObjectPrx>& coordinator, std::int32_t max, std::int64_t generation, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_ready(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int32_t, std::string_view, const std::optional<Ice::ObjectPrx>&, std::int32_t, std::int64_t, const Ice::Context&) const;

        /// Called to accept an invitation into the given group.
        /// @param j The id of the node accepting the invitation.
        /// @param gn The group name.
        /// @param forwardedInvites The ids of the nodes to which invitations were forwarded.
        /// @param observer The observer.
        /// @param llu The last log update for the given node.
        /// @param max The highest priority node seen by this replica group.
        /// @param context The request context.
        void accept(std::int32_t j, std::string_view gn, const ::Ice::IntSeq& forwardedInvites, const std::optional<Ice::ObjectPrx>& observer, const LogUpdate& llu, std::int32_t max, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Called to accept an invitation into the given group.
        /// @param j The id of the node accepting the invitation.
        /// @param gn The group name.
        /// @param forwardedInvites The ids of the nodes to which invitations were forwarded.
        /// @param observer The observer.
        /// @param llu The last log update for the given node.
        /// @param max The highest priority node seen by this replica group.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> acceptAsync(std::int32_t j, std::string_view gn, const ::Ice::IntSeq& forwardedInvites, const std::optional<Ice::ObjectPrx>& observer, const LogUpdate& llu, std::int32_t max, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Called to accept an invitation into the given group.
        /// @param j The id of the node accepting the invitation.
        /// @param gn The group name.
        /// @param forwardedInvites The ids of the nodes to which invitations were forwarded.
        /// @param observer The observer.
        /// @param llu The last log update for the given node.
        /// @param max The highest priority node seen by this replica group.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> acceptAsync(std::int32_t j, std::string_view gn, const ::Ice::IntSeq& forwardedInvites, const std::optional<Ice::ObjectPrx>& observer, const LogUpdate& llu, std::int32_t max, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_accept(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, std::int32_t, std::string_view, const ::Ice::IntSeq&, const std::optional<Ice::ObjectPrx>&, const LogUpdate&, std::int32_t, const Ice::Context&) const;

        /// Determine if this node is a coordinator.
        /// @param context The request context.
        /// @return `true` if the node is a coordinator, `false` otherwise.
        bool areYouCoordinator(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Determine if this node is a coordinator.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - `true` if the node is a coordinator, `false` otherwise.
        [[nodiscard]] std::future<bool> areYouCoordinatorAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Determine if this node is a coordinator.
        /// @param response The response callback. It accepts:
        /// - `true` if the node is a coordinator, `false` otherwise.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> areYouCoordinatorAsync(std::function<void(bool)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_areYouCoordinator(const std::shared_ptr<IceInternal::OutgoingAsyncT<bool>>&, const Ice::Context&) const;

        /// Determine if the node is a member of the given group with the given coordinator.
        /// @param gn The group name.
        /// @param j The group coordinator.
        /// @param context The request context.
        /// @return `true` if the node is a member, `false` otherwise.
        bool areYouThere(std::string_view gn, std::int32_t j, const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Determine if the node is a member of the given group with the given coordinator.
        /// @param gn The group name.
        /// @param j The group coordinator.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - `true` if the node is a member, `false` otherwise.
        [[nodiscard]] std::future<bool> areYouThereAsync(std::string_view gn, std::int32_t j, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Determine if the node is a member of the given group with the given coordinator.
        /// @param gn The group name.
        /// @param j The group coordinator.
        /// @param response The response callback. It accepts:
        /// - `true` if the node is a member, `false` otherwise.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> areYouThereAsync(std::string_view gn, std::int32_t j, std::function<void(bool)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_areYouThere(const std::shared_ptr<IceInternal::OutgoingAsyncT<bool>>&, std::string_view, std::int32_t, const Ice::Context&) const;

        /// Get the sync object for the replica hosted by this node.
        /// @param context The request context.
        /// @return The sync object.
        std::optional<Ice::ObjectPrx> sync(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Get the sync object for the replica hosted by this node.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The sync object.
        [[nodiscard]] std::future<std::optional<Ice::ObjectPrx>> syncAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Get the sync object for the replica hosted by this node.
        /// @param response The response callback. It accepts:
        /// - The sync object.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> syncAsync(std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_sync(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>&, const Ice::Context&) const;

        /// Get the replication group information.
        /// @param context The request context.
        /// @return The set of configured nodes and the associated priority.
        NodeInfoSeq nodes(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Get the replication group information.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The set of configured nodes and the associated priority.
        [[nodiscard]] std::future<NodeInfoSeq> nodesAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Get the replication group information.
        /// @param response The response callback. It accepts:
        /// - The set of configured nodes and the associated priority.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> nodesAsync(std::function<void(::IceStormElection::NodeInfoSeq)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_nodes(const std::shared_ptr<IceInternal::OutgoingAsyncT<NodeInfoSeq>>&, const Ice::Context&) const;

        /// Get the query information for the given node.
        /// @param context The request context.
        /// @return The query information.
        QueryInfo query(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Get the query information for the given node.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The query information.
        [[nodiscard]] std::future<QueryInfo> queryAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Get the query information for the given node.
        /// @param response The response callback. It accepts:
        /// - The query information.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> queryAsync(std::function<void(::IceStormElection::QueryInfo)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_query(const std::shared_ptr<IceInternal::OutgoingAsyncT<QueryInfo>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStormElection::Node"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static NodePrx _fromReference(IceInternal::ReferencePtr ref) { return NodePrx{std::move(ref)}; }

    protected:
        /// @private
        NodePrx() = default;

        /// @private
        explicit NodePrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };
}

namespace IceStormElection
{
    /// The contents of topic.
    struct TopicContent
    {
        /// The topic identity.
        ::Ice::Identity id;

        /// The topic subscribers.
        ::IceStorm::SubscriberRecordSeq records;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const ::Ice::Identity&, const ::IceStorm::SubscriberRecordSeq&> ice_tuple() const
        {
            return std::tie(id, records);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a TopicContent to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const TopicContent& value);

    /// Thrown if an observer detects an inconsistency.
    class ObserverInconsistencyException : public Ice::UserException
    {
    public:
        /// Default constructor.
        ObserverInconsistencyException() noexcept = default;

        /// One-shot constructor to initialize all data members.
        /// @param reason The reason for the inconsistency.
        ObserverInconsistencyException(std::string reason) noexcept :
            reason(std::move(reason))
        {
        }

        /// Copy constructor.
        ObserverInconsistencyException(const ObserverInconsistencyException&) noexcept = default;

        /// Creates a tuple with all the fields of this exception.
        /// @return A tuple with all the fields of this exception.
        [[nodiscard]] std::tuple<const std::string&> ice_tuple() const
        {
            return std::tie(reason);
        }

        void ice_printFields(std::ostream& os) const override;
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStormElection::ObserverInconsistencyException"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        /// The reason for the inconsistency.
        std::string reason;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// All nodes in the replication group.
    struct NodeInfo
    {
        /// The identity of the node.
        std::int32_t id;

        /// The node proxy.
        std::optional<::IceStormElection::NodePrx> n;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::optional<::IceStormElection::NodePrx>&> ice_tuple() const
        {
            return std::tie(id, n);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a NodeInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const NodeInfo& value);

    /// The group info.
    struct GroupInfo
    {
        /// The identity of the node.
        std::int32_t id;

        /// The last known log update for this node.
        ::IceStormElection::LogUpdate llu;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int32_t&, const ::IceStormElection::LogUpdate&> ice_tuple() const
        {
            return std::tie(id, llu);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a GroupInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const GroupInfo& value);

    struct QueryInfo
    {
        /// The node id.
        std::int32_t id;

        /// The nodes coordinator.
        std::int32_t coord;

        /// The nodes group name.
        std::string group;

        /// The replica the node is managing.
        std::optional<Ice::ObjectPrx> replica;

        /// The node state.
        ::IceStormElection::NodeState state;

        /// The sequence of nodes in this nodes group.
        ::IceStormElection::GroupInfoSeq up;

        /// The highest priority node that this node has seen.
        std::int32_t max;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::int32_t&, const std::string&, const std::optional<Ice::ObjectPrx>&, const ::IceStormElection::NodeState&, const ::IceStormElection::GroupInfoSeq&, const std::int32_t&> ice_tuple() const
        {
            return std::tie(id, coord, group, replica, state, up, max);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of a QueryInfo to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const QueryInfo& value);

    /// @cond INTERNAL
    using Ice::Tuple::operator<;
    using Ice::Tuple::operator<=;
    using Ice::Tuple::operator>;
    using Ice::Tuple::operator>=;
    using Ice::Tuple::operator==;
    using Ice::Tuple::operator!=;
    /// @endcond
}

namespace IceStormElection
{
    /// The replica observer.
    class ReplicaObserver : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = ReplicaObserverPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Initialize the observer.
        /// @param llu The last log update seen by the master.
        /// @param content The topic content.
        /// @param current The Current object of the incoming request.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        virtual void init(LogUpdate llu, TopicContentSeq content, const Ice::Current& current) = 0;

        /// @private
        void _iceD_init(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Create the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param current The Current object of the incoming request.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        virtual void createTopic(LogUpdate llu, std::string name, const Ice::Current& current) = 0;

        /// @private
        void _iceD_createTopic(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Destroy the topic with the given name.
        /// @param llu The log update token.
        /// @param name The topic name.
        /// @param current The Current object of the incoming request.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        virtual void destroyTopic(LogUpdate llu, std::string name, const Ice::Current& current) = 0;

        /// @private
        void _iceD_destroyTopic(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Add a subscriber to a topic.
        /// @param llu The log update token.
        /// @param topic The topic name to which to add the subscriber.
        /// @param record The subscriber information.
        /// @param current The Current object of the incoming request.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        virtual void addSubscriber(LogUpdate llu, std::string topic, ::IceStorm::SubscriberRecord record, const Ice::Current& current) = 0;

        /// @private
        void _iceD_addSubscriber(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Remove a subscriber from a topic.
        /// @param llu The log update token.
        /// @param topic The topic name.
        /// @param subscribers The identities of the subscribers to remove.
        /// @param current The Current object of the incoming request.
        /// @throws IceStormElection::ObserverInconsistencyException Raised if an inconsistency was detected.
        virtual void removeSubscriber(LogUpdate llu, std::string topic, ::Ice::IdentitySeq subscribers, const Ice::Current& current) = 0;

        /// @private
        void _iceD_removeSubscriber(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStormElection::ReplicaObserver"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a ReplicaObserver.
    using ReplicaObserverPtr = std::shared_ptr<ReplicaObserver>;

    /// Interface used to sync topics.
    class TopicManagerSync : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = TopicManagerSyncPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Retrieve the topic content.
        /// @param[out] llu The last log update token.
        /// @param[out] content The topic content.
        /// @param current The Current object of the incoming request.
        virtual void getContent(LogUpdate& llu, TopicContentSeq& content, const Ice::Current& current) = 0;

        /// @private
        void _iceD_getContent(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStormElection::TopicManagerSync"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a TopicManagerSync.
    using TopicManagerSyncPtr = std::shared_ptr<TopicManagerSync>;

    /// A replica node.
    class Node : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = NodePrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Invite the node into a group with the given coordinator and group name.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param current The Current object of the incoming request.
        virtual void invitation(std::int32_t j, std::string gn, const Ice::Current& current) = 0;

        /// @private
        void _iceD_invitation(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Call from the group coordinator to a node to inform the node that the replica group is active.
        /// @param j The group coordinator.
        /// @param gn The group name.
        /// @param coordinator The proxy to the coordinator.
        /// @param max The highest priority node seen by this replica group.
        /// @param generation The current generation count.
        /// @param current The Current object of the incoming request.
        virtual void ready(std::int32_t j, std::string gn, std::optional<Ice::ObjectPrx> coordinator, std::int32_t max, std::int64_t generation, const Ice::Current& current) = 0;

        /// @private
        void _iceD_ready(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Called to accept an invitation into the given group.
        /// @param j The id of the node accepting the invitation.
        /// @param gn The group name.
        /// @param forwardedInvites The ids of the nodes to which invitations were forwarded.
        /// @param observer The observer.
        /// @param llu The last log update for the given node.
        /// @param max The highest priority node seen by this replica group.
        /// @param current The Current object of the incoming request.
        virtual void accept(std::int32_t j, std::string gn, ::Ice::IntSeq forwardedInvites, std::optional<Ice::ObjectPrx> observer, LogUpdate llu, std::int32_t max, const Ice::Current& current) = 0;

        /// @private
        void _iceD_accept(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Determine if this node is a coordinator.
        /// @param current The Current object of the incoming request.
        /// @return `true` if the node is a coordinator, `false` otherwise.
        [[nodiscard]] virtual bool areYouCoordinator(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_areYouCoordinator(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Determine if the node is a member of the given group with the given coordinator.
        /// @param gn The group name.
        /// @param j The group coordinator.
        /// @param current The Current object of the incoming request.
        /// @return `true` if the node is a member, `false` otherwise.
        [[nodiscard]] virtual bool areYouThere(std::string gn, std::int32_t j, const Ice::Current& current) const = 0;

        /// @private
        void _iceD_areYouThere(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Get the sync object for the replica hosted by this node.
        /// @param current The Current object of the incoming request.
        /// @return The sync object.
        [[nodiscard]] virtual std::optional<Ice::ObjectPrx> sync(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_sync(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Get the replication group information.
        /// @param current The Current object of the incoming request.
        /// @return The set of configured nodes and the associated priority.
        [[nodiscard]] virtual NodeInfoSeq nodes(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_nodes(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Get the query information for the given node.
        /// @param current The Current object of the incoming request.
        /// @return The query information.
        [[nodiscard]] virtual QueryInfo query(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_query(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStormElection::Node"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a Node.
    using NodePtr = std::shared_ptr<Node>;
}

namespace Ice
{
    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStormElection::TopicContent>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 3;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::IceStormElection::TopicContent>
    {
        /// Unmarshals a ::IceStormElection::TopicContent from the input stream.
        static void read(InputStream* istr, ::IceStormElection::TopicContent& v)
        {
            istr->readAll(v.id, v.records);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStormElection::NodeState>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryEnum;
        static constexpr int minValue = 0;
        static constexpr int maxValue = 3;
        static constexpr int minWireSize = 1;
        static constexpr bool fixedLength = false;
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStormElection::NodeInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 6;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::IceStormElection::NodeInfo>
    {
        /// Unmarshals a ::IceStormElection::NodeInfo from the input stream.
        static void read(InputStream* istr, ::IceStormElection::NodeInfo& v)
        {
            istr->readAll(v.id, v.n);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStormElection::GroupInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 20;
        static constexpr bool fixedLength = true;
    };

    template<>
    struct StreamReader<::IceStormElection::GroupInfo>
    {
        /// Unmarshals a ::IceStormElection::GroupInfo from the input stream.
        static void read(InputStream* istr, ::IceStormElection::GroupInfo& v)
        {
            istr->readAll(v.id, v.llu);
        }
    };
    /// @endcond

    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStormElection::QueryInfo>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 17;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::IceStormElection::QueryInfo>
    {
        /// Unmarshals a ::IceStormElection::QueryInfo from the input stream.
        static void read(InputStream* istr, ::IceStormElection::QueryInfo& v)
        {
            istr->readAll(v.id, v.coord, v.group, v.replica, v.state, v.up, v.max);
        }
    };
    /// @endcond
}

// NOLINTEND(modernize-concat-nested-namespaces)

#include <Ice/PopDisableWarnings.h>
#endif
