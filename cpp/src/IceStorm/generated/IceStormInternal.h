// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'IceStormInternal.ice'.</auto-generated>
// clang-format off

#ifndef IceStormInternal_h_
#define IceStormInternal_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceStorm/IceStorm.h>
#include "Election.h"
#include <Ice/Context.h>
#include <Ice/OperationMode.h>
#include <deque>

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

// NOLINTBEGIN(modernize-concat-nested-namespaces)

namespace IceStorm
{
    struct EventData;

    /// A sequence of EventData.
    using EventDataSeq = std::deque<IceStorm::EventData>;

    class TopicLinkPrx;

    class TopicInternalPrx;

    class TopicManagerInternalPrx;
}

namespace IceStorm
{
    /// The TopicLink interface. This is used to forward events between federated Topic instances.
    /// @see TopicInternal
    class TopicLinkPrx : public Ice::Proxy<TopicLinkPrx, Ice::ObjectPrx>
    {
    public:
        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        TopicLinkPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        TopicLinkPrx(const TopicLinkPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        TopicLinkPrx(TopicLinkPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~TopicLinkPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        TopicLinkPrx& operator=(const TopicLinkPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        TopicLinkPrx& operator=(TopicLinkPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Forward a sequence of events.
        /// @param events The events to forward.
        /// @param context The request context.
        void forward(const EventDataSeq& events, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Forward a sequence of events.
        /// @param events The events to forward.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> forwardAsync(const EventDataSeq& events, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Forward a sequence of events.
        /// @param events The events to forward.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> forwardAsync(const EventDataSeq& events, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_forward(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const EventDataSeq&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicLink"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static TopicLinkPrx _fromReference(IceInternal::ReferencePtr ref) { return TopicLinkPrx{std::move(ref)}; }

    protected:
        /// @private
        TopicLinkPrx() = default;

        /// @private
        explicit TopicLinkPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }
    };

    /// Internal operations for a topic.
    /// @see Topic
    class TopicInternalPrx : public Ice::Proxy<TopicInternalPrx, TopicPrx>
    {
    public:
#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        TopicInternalPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        TopicInternalPrx(const TopicInternalPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        TopicInternalPrx(TopicInternalPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~TopicInternalPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        TopicInternalPrx& operator=(const TopicInternalPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        TopicInternalPrx& operator=(TopicInternalPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Retrieve a proxy to the TopicLink interface.
        /// @param context The request context.
        /// @return The TopicLink for the Topic.
        std::optional<TopicLinkPrx> getLinkProxy(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Retrieve a proxy to the TopicLink interface.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The TopicLink for the Topic.
        [[nodiscard]] std::future<std::optional<TopicLinkPrx>> getLinkProxyAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Retrieve a proxy to the TopicLink interface.
        /// @param response The response callback. It accepts:
        /// - The TopicLink for the Topic.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getLinkProxyAsync(std::function<void(std::optional<::IceStorm::TopicLinkPrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getLinkProxy(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<TopicLinkPrx>>>&, const Ice::Context&) const;

        /// Reap the given identities.
        /// @param id The sequence of identities.
        /// @param context The request context.
        /// @throws IceStorm::ReapWouldBlock Raised if the reap call would block.
        void reap(const ::Ice::IdentitySeq& id, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Reap the given identities.
        /// @param id The sequence of identities.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes.
        [[nodiscard]] std::future<void> reapAsync(const ::Ice::IdentitySeq& id, const Ice::Context& context = Ice::noExplicitContext) const;

        /// Reap the given identities.
        /// @param id The sequence of identities.
        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> reapAsync(const ::Ice::IdentitySeq& id, std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_reap(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const ::Ice::IdentitySeq&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicInternal"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static TopicInternalPrx _fromReference(IceInternal::ReferencePtr ref) { return TopicInternalPrx{std::move(ref)}; }

    protected:
        /// @private
        TopicInternalPrx() = default;

        /// @private
        explicit TopicInternalPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }

#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic pop
#endif
    };

    /// Internal operations for a topic manager.
    /// @see TopicManager
    class TopicManagerInternalPrx : public Ice::Proxy<TopicManagerInternalPrx, TopicManagerPrx>
    {
    public:
#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

        /// Constructs a proxy from a Communicator and a proxy string.
        /// @param communicator The communicator of the new proxy.
        /// @param proxyString The proxy string to parse.
        TopicManagerInternalPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx{communicator, proxyString} {} // NOLINT(modernize-use-equals-default)

        /// Copy constructor. Constructs with a copy of the contents of @p other.
        /// @param other The proxy to copy from.
        TopicManagerInternalPrx(const TopicManagerInternalPrx& other) noexcept : Ice::ObjectPrx{other} {} // NOLINT(modernize-use-equals-default)

        /// Move constructor. Constructs a proxy with the contents of @p other using move semantics.
        /// @param other The proxy to move from.
        TopicManagerInternalPrx(TopicManagerInternalPrx&& other) noexcept : Ice::ObjectPrx{std::move(other)} {} // NOLINT(modernize-use-equals-default)

        ~TopicManagerInternalPrx() override;

        /// Copy assignment operator. Replaces the contents of this proxy with a copy of the contents of @p rhs.
        /// @param rhs The proxy to copy from.
        /// @return A reference to this proxy.
        TopicManagerInternalPrx& operator=(const TopicManagerInternalPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        /// Move assignment operator. Replaces the contents of this proxy with the contents of @p rhs using move semantics.
        /// @param rhs The proxy to move from.
        TopicManagerInternalPrx& operator=(TopicManagerInternalPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// Return the replica node proxy for this topic manager.
        /// @param context The request context.
        /// @return The replica proxy, or null if this instance is not replicated.
        std::optional<::IceStormElection::NodePrx> getReplicaNode(const Ice::Context& context = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        /// Return the replica node proxy for this topic manager.
        /// @param context The request context.
        /// @return A future that becomes available when the invocation completes. This future holds:
        /// - The replica proxy, or null if this instance is not replicated.
        [[nodiscard]] std::future<std::optional<::IceStormElection::NodePrx>> getReplicaNodeAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// Return the replica node proxy for this topic manager.
        /// @param response The response callback. It accepts:
        /// - The replica proxy, or null if this instance is not replicated.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The request context.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> getReplicaNodeAsync(std::function<void(std::optional<::IceStormElection::NodePrx>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @private
        void _iceI_getReplicaNode(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<::IceStormElection::NodePrx>>>&, const Ice::Context&) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicManagerInternal"`.
        static const char* ice_staticId() noexcept;

        /// @private
        static TopicManagerInternalPrx _fromReference(IceInternal::ReferencePtr ref) { return TopicManagerInternalPrx{std::move(ref)}; }

    protected:
        /// @private
        TopicManagerInternalPrx() = default;

        /// @private
        explicit TopicManagerInternalPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx{std::move(ref)}
        {
        }

#if defined(__GNUC__) && !defined(__clang__)
#   pragma GCC diagnostic pop
#endif
    };
}

namespace IceStorm
{
    /// The event data.
    struct EventData
    {
        /// The operation name.
        std::string op;

        /// The operation mode.
        ::Ice::OperationMode mode;

        /// The encoded data for the operation's input parameters.
        ::Ice::ByteSeq data;

        /// The Ice::Current::Context data from the originating request.
        ::Ice::Context context;

        /// Creates a tuple with all the fields of this struct.
        /// @return A tuple with all the fields of this struct.
        [[nodiscard]] std::tuple<const std::string&, const ::Ice::OperationMode&, const ::Ice::ByteSeq&, const ::Ice::Context&> ice_tuple() const
        {
            return std::tie(op, mode, data, context);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    /// Outputs the description of an EventData to a stream, including all its fields.
    /// @param os The output stream.
    /// @param value The instance to output.
    /// @return The output stream.
    std::ostream& operator<<(std::ostream& os, const EventData& value);

    /// Thrown if the reap call would block.
    class ReapWouldBlock : public Ice::UserException
    {
    public:
        /// Gets the type ID of the associated Slice exception.
        /// @return The string `"::IceStorm::ReapWouldBlock"`.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

    protected:
        /// @private
        void _writeImpl(Ice::OutputStream*) const override;

        /// @private
        void _readImpl(Ice::InputStream*) override;
    };

    /// @cond INTERNAL
    using Ice::Tuple::operator<;
    using Ice::Tuple::operator<=;
    using Ice::Tuple::operator>;
    using Ice::Tuple::operator>=;
    using Ice::Tuple::operator==;
    using Ice::Tuple::operator!=;
    /// @endcond
}

namespace IceStorm
{
    /// The TopicLink interface. This is used to forward events between federated Topic instances.
    /// @see TopicInternal
    class TopicLink : public virtual Ice::Object
    {
    public:
        /// The associated proxy type.
        using ProxyType = TopicLinkPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Forward a sequence of events.
        /// @param events The events to forward.
        /// @param current The Current object of the incoming request.
        virtual void forward(EventDataSeq events, const Ice::Current& current) = 0;

        /// @private
        void _iceD_forward(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicLink"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a TopicLink.
    using TopicLinkPtr = std::shared_ptr<TopicLink>;

    /// Internal operations for a topic.
    /// @see Topic
    class TopicInternal : public virtual Topic
    {
    public:
        /// The associated proxy type.
        using ProxyType = TopicInternalPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Retrieve a proxy to the TopicLink interface.
        /// @param current The Current object of the incoming request.
        /// @return The TopicLink for the Topic.
        virtual std::optional<TopicLinkPrx> getLinkProxy(const Ice::Current& current) = 0;

        /// @private
        void _iceD_getLinkProxy(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Reap the given identities.
        /// @param id The sequence of identities.
        /// @param current The Current object of the incoming request.
        /// @throws IceStorm::ReapWouldBlock Raised if the reap call would block.
        virtual void reap(::Ice::IdentitySeq id, const Ice::Current& current) = 0;

        /// @private
        void _iceD_reap(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicInternal"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a TopicInternal.
    using TopicInternalPtr = std::shared_ptr<TopicInternal>;

    /// Internal operations for a topic manager.
    /// @see TopicManager
    class TopicManagerInternal : public virtual TopicManager
    {
    public:
        /// The associated proxy type.
        using ProxyType = TopicManagerInternalPrx;

        /// Dispatches an incoming request to one of the member functions of this generated class, based on the operation name carried by the request.
        /// @param request The incoming request.
        /// @param sendResponse The callback to send the response.
        void dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse) override;

        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Return the replica node proxy for this topic manager.
        /// @param current The Current object of the incoming request.
        /// @return The replica proxy, or null if this instance is not replicated.
        [[nodiscard]] virtual std::optional<::IceStormElection::NodePrx> getReplicaNode(const Ice::Current& current) const = 0;

        /// @private
        void _iceD_getReplicaNode(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) const;

        /// Gets the type ID of the associated Slice interface.
        /// @return The string `"::IceStorm::TopicManagerInternal"`.
        static const char* ice_staticId() noexcept;
    };

    /// A shared pointer to a TopicManagerInternal.
    using TopicManagerInternalPtr = std::shared_ptr<TopicManagerInternal>;
}

namespace Ice
{
    /// @cond INTERNAL
    template<>
    struct StreamableTraits<::IceStorm::EventData>
    {
        static constexpr StreamHelperCategory helper = StreamHelperCategoryStruct;
        static constexpr int minWireSize = 4;
        static constexpr bool fixedLength = false;
    };

    template<>
    struct StreamReader<::IceStorm::EventData>
    {
        /// Unmarshals a ::IceStorm::EventData from the input stream.
        static void read(InputStream* istr, ::IceStorm::EventData& v)
        {
            istr->readAll(v.op, v.mode, v.data, v.context);
        }
    };
    /// @endcond
}

// NOLINTEND(modernize-concat-nested-namespaces)

#include <Ice/PopDisableWarnings.h>
#endif
