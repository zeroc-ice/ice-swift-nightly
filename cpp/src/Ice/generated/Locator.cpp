// Copyright (c) ZeroC, Inc.

// slice2cpp version 3.8.0-alpha.0
// <auto-generated>Generated from Slice file 'Locator.ice'.</auto-generated>

#ifndef ICE_API_EXPORTS
#   define ICE_API_EXPORTS
#endif
#define ICE_BUILDING_GENERATED_CODE

#include "Ice/Locator.h"
#include <Ice/LocatorRegistry.h>
#include <Ice/AsyncResponseHandler.h>
#include <Ice/DefaultSliceLoader.h>
#include <Ice/OutgoingAsync.h>
#include <algorithm>
#include <array>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_DISABLE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{
    const IceInternal::ExceptionInit<::Ice::AdapterNotFoundException> iceC_Ice_AdapterNotFoundException_init;
    const IceInternal::ExceptionInit<::Ice::ObjectNotFoundException> iceC_Ice_ObjectNotFoundException_init;
}

Ice::LocatorPrx::~LocatorPrx() = default;

std::optional<Ice::ObjectPrx>
Ice::LocatorPrx::findObjectById(const Identity& iceP_id, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<Ice::ObjectPrx>>(true, this, &LocatorPrx::_iceI_findObjectById, iceP_id, context).get();
}

std::future<std::optional<Ice::ObjectPrx>>
Ice::LocatorPrx::findObjectByIdAsync(const Identity& iceP_id, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<Ice::ObjectPrx>>(false, this, &LocatorPrx::_iceI_findObjectById, iceP_id, context);
}

std::function<void()>
Ice::LocatorPrx::findObjectByIdAsync(const Identity& iceP_id, std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<std::optional<Ice::ObjectPrx>>(std::move(response), std::move(exception), std::move(sent), this, &Ice::LocatorPrx::_iceI_findObjectById, iceP_id, context);
}

void
Ice::LocatorPrx::_iceI_findObjectById(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>& outAsync, const Identity& iceP_id, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "findObjectById";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Idempotent,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const ObjectNotFoundException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

std::optional<Ice::ObjectPrx>
Ice::LocatorPrx::findAdapterById(std::string_view iceP_id, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<Ice::ObjectPrx>>(true, this, &LocatorPrx::_iceI_findAdapterById, iceP_id, context).get();
}

std::future<std::optional<Ice::ObjectPrx>>
Ice::LocatorPrx::findAdapterByIdAsync(std::string_view iceP_id, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<Ice::ObjectPrx>>(false, this, &LocatorPrx::_iceI_findAdapterById, iceP_id, context);
}

std::function<void()>
Ice::LocatorPrx::findAdapterByIdAsync(std::string_view iceP_id, std::function<void(std::optional<Ice::ObjectPrx>)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<std::optional<Ice::ObjectPrx>>(std::move(response), std::move(exception), std::move(sent), this, &Ice::LocatorPrx::_iceI_findAdapterById, iceP_id, context);
}

void
Ice::LocatorPrx::_iceI_findAdapterById(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<Ice::ObjectPrx>>>& outAsync, std::string_view iceP_id, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "findAdapterById";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Idempotent,
        std::nullopt,
        context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch (const AdapterNotFoundException&)
            {
                throw;
            }
            catch (const Ice::UserException&)
            {
            }
        });
}

std::optional<::Ice::LocatorRegistryPrx>
Ice::LocatorPrx::getRegistry(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<LocatorRegistryPrx>>(true, this, &LocatorPrx::_iceI_getRegistry, context).get();
}

std::future<std::optional<::Ice::LocatorRegistryPrx>>
Ice::LocatorPrx::getRegistryAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<LocatorRegistryPrx>>(false, this, &LocatorPrx::_iceI_getRegistry, context);
}

std::function<void()>
Ice::LocatorPrx::getRegistryAsync(std::function<void(std::optional<::Ice::LocatorRegistryPrx>)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<std::optional<LocatorRegistryPrx>>(std::move(response), std::move(exception), std::move(sent), this, &Ice::LocatorPrx::_iceI_getRegistry, context);
}

void
Ice::LocatorPrx::_iceI_getRegistry(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<LocatorRegistryPrx>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getRegistry";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Idempotent,
        std::nullopt,
        context,
        nullptr,
        nullptr);
}

const char*
Ice::LocatorPrx::ice_staticId() noexcept
{
    return "::Ice::Locator";
}

Ice::LocatorFinderPrx::~LocatorFinderPrx() = default;

std::optional<::Ice::LocatorPrx>
Ice::LocatorFinderPrx::getLocator(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<LocatorPrx>>(true, this, &LocatorFinderPrx::_iceI_getLocator, context).get();
}

std::future<std::optional<::Ice::LocatorPrx>>
Ice::LocatorFinderPrx::getLocatorAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::optional<LocatorPrx>>(false, this, &LocatorFinderPrx::_iceI_getLocator, context);
}

std::function<void()>
Ice::LocatorFinderPrx::getLocatorAsync(std::function<void(std::optional<::Ice::LocatorPrx>)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<std::optional<LocatorPrx>>(std::move(response), std::move(exception), std::move(sent), this, &Ice::LocatorFinderPrx::_iceI_getLocator, context);
}

void
Ice::LocatorFinderPrx::_iceI_getLocator(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<LocatorPrx>>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "getLocator";

    _checkTwowayOnly(operationName);
    outAsync->invoke(
        operationName,
        Ice::OperationMode::Normal,
        std::nullopt,
        context,
        nullptr,
        nullptr);
}

const char*
Ice::LocatorFinderPrx::ice_staticId() noexcept
{
    return "::Ice::LocatorFinder";
}

const char*
Ice::AdapterNotFoundException::ice_staticId() noexcept
{
    return "::Ice::AdapterNotFoundException";
}

const char*
Ice::AdapterNotFoundException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Ice::AdapterNotFoundException::ice_throw() const
{
    throw *this;
}

void
Ice::AdapterNotFoundException::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->endSlice();
}

void
Ice::AdapterNotFoundException::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->endSlice();
}

const char*
Ice::ObjectNotFoundException::ice_staticId() noexcept
{
    return "::Ice::ObjectNotFoundException";
}

const char*
Ice::ObjectNotFoundException::ice_id() const noexcept
{
    return ice_staticId();
}

void
Ice::ObjectNotFoundException::ice_throw() const
{
    throw *this;
}

void
Ice::ObjectNotFoundException::_writeImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->endSlice();
}

void
Ice::ObjectNotFoundException::_readImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->endSlice();
}

void
Ice::Locator::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 7> allOperations{"findAdapterById", "findObjectById", "getRegistry", "ice_id", "ice_ids", "ice_isA", "ice_ping"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_findAdapterById(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_findObjectById(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_getRegistry(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
Ice::Locator::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::Ice::Locator", "::Ice::Object"};
    return allTypeIds;
}

std::string
Ice::Locator::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

void
Ice::Locator::_iceD_findObjectById(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) const
{
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    Identity iceP_id;
    istr->readAll(iceP_id);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const std::optional<Ice::ObjectPrx>& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
            });
    };
    try
    {
        this->findObjectByIdAsync(std::move(iceP_id), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}

void
Ice::Locator::_iceD_findAdapterById(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) const
{
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    std::string iceP_id;
    istr->readAll(iceP_id);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const std::optional<Ice::ObjectPrx>& ret)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(ret);
            });
    };
    try
    {
        this->findAdapterByIdAsync(std::move(iceP_id), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}

void
Ice::Locator::_iceD_getRegistry(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) const // NOLINT(performance-unnecessary-value-param)
{
    request.inputStream().skipEmptyEncapsulation();
    const std::optional<LocatorRegistryPrx> ret = this->getRegistry(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}

const char*
Ice::Locator::ice_staticId() noexcept
{
    return "::Ice::Locator";
}

void
Ice::LocatorFinder::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 5> allOperations{"getLocator", "ice_id", "ice_ids", "ice_isA", "ice_ping"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_getLocator(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}

std::vector<std::string>
Ice::LocatorFinder::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::Ice::LocatorFinder", "::Ice::Object"};
    return allTypeIds;
}

std::string
Ice::LocatorFinder::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

void
Ice::LocatorFinder::_iceD_getLocator(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse) // NOLINT(performance-unnecessary-value-param)
{
    checkNonIdempotent(request.current());
    request.inputStream().skipEmptyEncapsulation();
    const std::optional<LocatorPrx> ret = this->getLocator(request.current());
    sendResponse(Ice::makeOutgoingResponse([&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(ret);
        },
        request.current()));
}

const char*
Ice::LocatorFinder::ice_staticId() noexcept
{
    return "::Ice::LocatorFinder";
}
